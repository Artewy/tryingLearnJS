// -------------------- lesson 1 -------------------- 
console.log(1);
"use strict"; // Современный режим (строгий)
// новая директива, современный код

let numberLesson1 = 5;
// let - объявление переменной (let), имя (numberLesson1), присваивание (=), значение (5)
const leftBorderWidth = 1;
// leftBorderWidth = 2;
console.log(leftBorderWidth);
// ширина левой границы 
// Переменная может начинаться с букв, 
// нижнего подчеркивания и доллара, также нельзя использовать слова error, 
// alert и тд (зарезервированные)
// console.log(1);
let number = 11;
number = 10;
console.log(number);

const obj = {
    a: 50
};
obj.a = 10;
console.log(obj);
// прямых констант не бывает!


// var name = 'Ivan' старый метод переменной, существует до того, как была объявлена в коде (Поднятие/всплытие (hoisting))


// особенность let:

// Неправильно, будет ошибка, работает внутри скобок

{
    let result1 = 50;
}
console.log(result1);

// Правильно

{
    let result = 50;
    console.log(result);
}


// less2

// Styles:
// snake_case -- один из вариантов названия папок и файлов
// UPPER_SNAKE_CASE -- вариант написания переменных в виде констант (цвета, )
// Kebab-case -- папки, файлы
// PascalCase -- классы
// camelCase -- переменные

let vehicleBodyWidth = 5000;
let vehicleBodyLength = 4000;

vehicleBodyWidth = 5000;
vehicleBodyLength = 4000;
console.log("Ширина кузова автомобиля: " + vehicleBodyWidth + ', длина: ' + vehicleBodyLength);





// ------------------------------ Homework #1 ------------------------------

// Создайте переменную, которая будет отображать имя пользователя. (Пользователь - user, имя - name). В неё поместите значение "John"
// На следующей строке создайте переменную, отображающую номер пользователя (номер - number). В неё поместите значение 25.
// Измените значение второй переменной с 25 на 24 на следующей строке.


const userName = "John";
let userNumber = 25;
userNumber = 24;





// -------------------- lesson 2 -------------------- 

// Типы данных в JS:
// Простые типы:

// Числа 1, 2, 3 (Infinity (+/-) - console.log(4/0), Not a Number (string * 9) - NaN - не число, нет мат логики)
let numberLesson2 = 4.6;
console.log(4 / 0);
console.log('string' * 9);

// Строки 'string', "name", либо тильда `name`
const person = "Alex";

// Логический тип (boolean) true/false
const bool = true;

// null - не существует
let something;
console.log(something);

// undefined - существует, но нет значения
let und;
console.log(und);

// Symbol

// BigInt - большие числа (> 2^53 - 1)
// Тип BigInt может быть определен с помощью оператора typeof:

// typeof 123;
// --> 'number'
// typeof 123n;
// --> 'bigint'
// typeof 123f; 
// --> с плавающей точкой


// Объекты (комплексные):
const object = {
    name: "John", // ключ (свойства) + значение
    age: 25, // данные -- свойства объекта, действия -- методы
    isMarried: false
};

console.log(object.name); // обращение к определенному свойству (данным) в объекте
console.log(object["name"]);

// 1) Спец. объекты 2) Обычные объекты

// Массивы [] ЧАСТНЫЙ СЛУЧАЙ ОБЪЕКТА, не является отдельным типом данных
let array = ['plum.png', 'orange.jpeg', 'apple.bmp', 6, [], {}];
console.log(array[1]); // только значение, нет ключа (он фиксирован, задан по умолчанию)
console.log(array[0]);
console.log(array[4]);

// Function


// Объект даты


// Регулярные выражения


// Ошибки


// -------------------- lesson 3 -------------------- 

// Разница между массивами и объектами
const arr = [1, 2, 3]; // Массив -- Перечень информации по порядку
const arrObj = { // Объект -- Структура хранения данных в парном формате
    a: 1,
    1: 2,
    2: 3
};

console.log(arr[1]);
console.log(arrObj.a);
console.log(arrObj[1]);

arrObj.bounty = '1337';
arrObj['bountyR'] = '228';
console.log(arrObj['bounty']); // Указание свойства, а не переменной
console.log(arrObj.bounty); // Обращение к свойству
console.log(arrObj['bountyR']);

// Можно и так, главное, чтобы переменная уже существовала
const b = 'b' // Если есть переменная, которая содержит определенное значение
// По сути, это динамические данные в объекте. В массиве можно также, но...
arr[10] = '345678';
console.log(arr[10]); // Нарушает логику, в массиве будет 7 пустых элементов
// Да, можно, но не нужно.

arrObj[b] = '1234'; // То можно ее использовать, чтобы создать новое свойство
console.log(arrObj['b']);
console.log(arrObj[b]);

// Внутри объектов можно создавать вложенные структуры (пример-фильмы/жанры):
const arrayObjectLess3 = {
    a: 'a',
    '1': 'b',
    2: 'c',
    abc: {
        df: [{}, {}],
        def: {

        }
    }
};


const objectLess3 = { a: 1, c: 2 }; // Структура хранения данных в парном формате

const objectLesson3 = {
    'Anna': 500,
    'Alice': 800
};

// Вот так плохо!  ['Anna', 500, 'Alice', 800]


// ------------------------------ Homework #2 ------------------------------

/* Создайте переменную с названием магазина (магазин - store, имя - name) и поместите в неё любое название на ваш выбор.
Создайте объект под названием storeDescription
во внутрь этого объекта напрямую поместите свойство budget и укажите его как 10000. 
Напрямую - это сразу внутри фигурных скобок, мы его расширяем на месте
Во внутрь объекта storeDescription напрямую поместите свойство employees. 
Это должен быть массив, который содержит имена трех сотрудников на ваш выбор
Во внутрь объекта storeDescription напрямую поместите свойство products. 
Это должен быть тоже объект, который содержит два товара и их цену. 
То есть, нужно создать пару ключ-значение в виде товар: цена. Данные на ваш выбор.
Во внутрь объекта storeDescription напрямую поместите свойство open. 
Тут можно контролировать: или магазин открыт, или закрыт, то есть логическое значение. Сделайте его открытым
*/



const storeName = "YSN";
const storeDescription = {
    budget: 10000,
    employees: ['Dasha', 'Artyom', 'Arseny'],
    products: {
        potatoes: 80,
        tomatoes: 150,
    },
    open: true
};

console.log(storeDescription['budget']);



// -------------------- lesson 4 -------------------- 

alert('Hello') // Встроенное в браузер окно. Предупреждение пользователя

const resultLess4 = confirm('Are u here?'); // Такое же окно с двумя вариантами ответа
console.log(resultLess4); // Запись результата true/false в консоль
const answer1 = prompt('Вы программист?', '');
console.log(typeof (answer1)); // Узнать тип данных
// Вся информация, приходящая от пользователя - СТРОКА!

const answer2 = +prompt('Вы программист?', ''); // Динамическая типизация
// Преобразование типа данных "строка" в "число"

const answer3 = prompt('Вы программист?', '');
console.log(typeof (answer3 + 5)); // Сложение строк: 10+5=105

const answer4 = +prompt('Вы программист?', '');
console.log(typeof (answer4 + 5)); // Сложение чисел: 10+5=15


// Зададим список вопросов, поместив их в массив
const answers = [];
answers[0] = prompt('Ваше имя', ''); // prompt существует в браузере!
answers[1] = prompt('Ваша фамилия', ''); // Это не переменная
answers[2] = prompt('Ваше отчество', ''); // Также с alert, confirm

document.write(answers); // Замена содержимого на то, что выводим
/* Однако 'Hello world' останется, т.к тег body пуст, не сформирован.
prompt, alert, confirm блокируют построение страницы до их выполнения
*/
console.log(typeof (answers)); // Объект! т.к массив - частный случай
// Однако есть ошибка console.log(typeof(null)); -- выведет object



// -------------------- lesson 5 (13) -------------------- 
// Интерполяция

const category = 'toys';

console.log('https://someurl.com/' + category + '/' + '4'); // Не круто

// Используем интерполяцию
console.log(`https://someurl.com/'${category}/5`); // Такой же результат

// Кавычки ТОЛЬКО ЧЕРЕЗ ТИЛЬДУ (бэктики)
const user = 'Artyom';
alert(`Привет, ${user}`);






// -------------------- lesson 6 (14) -------------------- 
// Операторы js

// Сложение

console.log('array' + " — object") // Сложение строк = 'array — object'
console.log('array' + +" — object") // Сложение строки с числом (унарный плюс) = 'NaN'
console.log('array' + 5) // Сложение строки с числом -- конкатенация. Результат -- строка
console.log('4' + +"5") // Сложение строки с числом (унарный плюс) = '45'
console.log('4' + 5) // Сложение строки с числом = '45'
console.log(4 + 5) // Сложение числа с числом = '9'

// Инкремент и декремент

let incr = 10,
    decr = 10;

incr++; // Увеличение на единицу (постфиксная форма записи). Префиксная '++incr;'
decr--; // Уменьшение на единицу (постфиксная форма записи). Префиксная '--decr;'

/* Разница в том, что при использовании постфиксной формы СРАЗУ (например, в console.log),
то она вернет старое значение. Использовал -> Старое значение -> Увеличение/уменьшение
Префиксная сразу же меняет. ТО ЕСТЬ:

ПРЕФИКСНАЯ форма возвращает новое значение, 
в то время как ПОСТФИКСНАЯ форма возвращает старое (до увеличения/уменьшения числа).
*/

/* 
console.log(incr++);
console.log(decr--);

Вывод: 10, 10


console.log(++incr);
console.log(--decr);

Вывод: 11, 9
*/

console.log(incr);
console.log(decr);

// Остаток от деления

console.log(5 % 2); // 1

// Равенство (==), ПРИСВАИВАНИЕ (=)

console.log(2 * 4 == 8); // true, сравнение ПО ЗНАЧЕНИЮ, а не по типам данных. можно сравнить число со строкой
console.log(2 * 4 === '8'); // Строгое сравнение (с типами данных). false

// Оператор И (&&)
// Оператор ИЛИ (||)
// Отрицание (!)

const isChecked = true,
    isClose = true;


console.log(isChecked && isClose); // true; 'isClose' = true, 'isChecked' = true.
console.log(isChecked || isClose); // true; 'isClose' = true, 'isChecked' = true.
console.log(isChecked || !isClose); // true; '!isClose' = false, 'isChecked' = true.


// Порядок выполнения операторов (приоритет)

/*
Чем больше приоритет (18 > 1), тем он выше

1) Запятая, последовательность (слева направо) '… , …'

2) Присваивание (=), 
Условный (тернарный) оператор (?), 
yield, 
yield* (СПРАВА НАЛЕВО) '… = …' '… ? … : …' 'yield …'

3) Логическое ИЛИ (||), 
Оператор нулевого слияния (??) (слева направо) '… || …' '… ?? …' 

4) Логическое «И» (&&) (слева направо) '… && …'

5) Побитовое «ИЛИ» (|) (слева направо) '… | …'

6) Побитовое исключающее «ИЛИ» (^) (слева направо) '… ^ …'

7) Побитовое «И» (&) (слева направо) '… & …'

8) Равенство (==), 
Неравенство (!=), 
Строгое равенство (===), 
Строгое неравенство (!==) (слева направо) '… == …' '… != …'

9) Меньше (<), 
Меньше или равно (<=), 
Больше (>), 
Больше или равно (>=), 
in, 
instanceof (слева направо) '… < …' '… <= …'

10) Побитовый сдвиг влево/вправо (<< / >>), 
Сдвиг вправо с заполнением нулей (>>>) (слева направо) '… << …' 

11) Сложение/Вычитание (+ / -) (слева направо) '… + …'

12) Умножение (*), Деление (/), Остаток от деления (%) (слева направо) '… * …' '… / …'

13) Возведение в степень (**) (СПРАВА НАЛЕВО) '… ** …'

14) Логическое отрицание (!), 
Побитовое отрицание (~), 
Унарный плюс/минус, 
Префиксный инкремент/декремент, 
typeof, 
void, 
delete, 
await (СПРАВА НАЛЕВО) '! …' '~ …'

15) Постфиксный инкремент/декремент (НЕ ОПРЕДЕЛЕНО) '… ++' '… --'

16) new (без списка аргументов) (СПРАВА НАЛЕВО) 'new …'

17) Доступ к свойствам (слева направо) '… . …', 
Доступ к свойствам с возможностью вычисления (слева направо) '… [ … ]', 
new (со списком аргументов) (НЕ ОПРЕДЕЛЕНО) 'new … ( … )', 
Вызов функции (слева направо) '… ( … )', 
Оператор опциональной последовательности (?.) (слева направо) '?.'

18) Группировка (НЕ ОПРЕДЕЛЕНО) '( … )'

*/


// -------------------- lesson 7 (15) -------------------- 

/* Система контроля версий Git. Сервис GitHub

Курс git — https://githowto.com/ru
git init — инициализация репозитория
Далее - настройка системы Git для отображения изменений
git config — конфигурация локально (указание другого имени, не распространяются на глобальные)
глобально (на весь ПК от нашего имени)  
git config --local user.name "Artem"
git config --local user.email example@gmail.com
git status — статус репозитория (commits - контрольные точки)
git add -A — добавить все файлы (add 'writeFileName' or '*.css' - все .css файлы)
git commit -a -m"first commit" — добавить контрольную точку, message, "..." - краткое содержание, что было сделано на этом commit'е
git log — когда и кем выполнены коммиты
*/


// -------------------- lesson 8 (16) -------------------- 

/* Продолжение Git. gitignore, Git Kraken 
cd - — (change directory) Вернуться назад
cd .. — Выйти на 1 уровень вверх
cd ../.. — Выйти на 2 уровня вверх
cd 'work' — Выйти в папку work
git clone 'URL' 'name folder' — клонирование репозитория на ПК в нужную папку
git pull — обновление старого файла на новый (используется для извлечения и загрузки содержимого из удаленного хранилища и 
немедленного обновления локального хранилища в соответствии с этим содержимым) — подгрузка из GitHub и обновление файла
Изменили проект (другой человек) - сразу пишем git pull!
Иначе будет ошибка, тогда:

git push --- error
git pull
'пишем коммит, т.к 2 проекта (с моего ПК (локальный репозиторий) и удаленного репозитория - merge'
ctrl + C дважды
:
wq! (write and quit)

!!!!!! Всего этого не будет, если сразу написать git pull

git fetch ПИЖЖЕ ЧЕМ pull

gitignore — часть файлов не надо пушить каждый раз на репозиторий. https://help/github/com/ignore-files/
GitKraken — удобный, красивый интерфейс для просмотра репозиториев 
*/


// -------------------- lesson 9 (17) -------------------- 

/* Подключение ПК к github через SSH (Secure shell) 
HTTP — HyperText Transfer Protocol
SSL certificate — secure sockets layer
FTP — File Transfer Protocol
SSH — Secure SHell - удаленное управление ОС и передача файлов

Плюсы HTTPS:
1. Проще (логин+пароль)
2. Доступ к сервису через авторизацию
3. Порт в ОС открыт
Минусы:
1. Ввод логин+пароль (изменение пароля - новый ввод)
2. Украли логин+пароль - плохо

Плюсы SSH:
1. Есть пара ключей - автоматическая авторизация
2. Ключи безопаснее за счет их размера (длина)
3. Первая настройка - простое подключение других устройств и ОС
4. Украли ключ - только смена информации в репозиториях
Минусы:
1. Первоначальная настройка не быстрое дело
2. Порт может быть заблокирован брандмауэром 
Подключение SSH: https://docs.github.com/en/authentication/connecting-to-github-with-ssh 
*/


// -------------------- lesson 10 (18) -------------------- 

/* Практическое задание 
1) Создать переменную numberOfFilms, в нее поместить ответ от пользователя на вопрос:
'Сколько фильмов вы уже посмотрели?'

let numberOfFilms = prompt('Сколько фильмов вы уже посмотрели?', '');
const personalMovieDB = {
    count: numberOfFilms,
    movies: {},
    actors: {},
    genres: [],
    private: false
};
const lastMovieYouWatched = prompt('Один из последних просмотренных фильмов?', '');
const scoreLastMovie = prompt('На сколько оцените его?', '');
console.log(lastMovieYouWatched);
console.log(scoreLastMovie);

personalMovieDB.movies.lastMovieYouWatched = prompt('Один из последних просмотренных фильмов?', '');
personalMovieDB.movies.scoreLastMovie = prompt('На сколько оцените его?', '');


2) Создать объект personalMovieDB и в него поместить свойства:
    — count — передается ответ на первый вопрос
    — movies — в это свойство поместить пустой объект
    — actors — тоже поместить пустой объект
    — genres — поместить пустой массив
    — private — поместить boolean значение false

3) Задайте пользователю по 2 раза вопросы:
    — 'Один из последних просмотренных фильмов?'
    — 'На сколько оцените его?'
Ответы стоит поместить в отдельные переменные.
Записать ответы в объект movies в формате:
    movies: {
        'logan': '8.1'
    }
Проверить, чтобы все работало без ошибок в консоли
*/

let numberOfFilms = prompt('Сколько фильмов вы уже посмотрели?', '');
const personalMovieDB = {
    count: numberOfFilms,
    movies: {},
    actors: {},
    genres: [],
    privat: false
};

// const lastMovieYouWatched = prompt('Один из последних просмотренных фильмов?', '');
// const scoreLastMovie = prompt('На сколько оцените его?', '');
// console.log(lastMovieYouWatched);
// console.log(scoreLastMovie);

personalMovieDB.movies.lastMovieYouWatched = prompt('Один из последних просмотренных фильмов?', '');
personalMovieDB.movies.scoreLastMovie = prompt('На сколько оцените его?', '');

personalMovieDB.movies.lastMovieYouWatched = prompt('Один из последних просмотренных фильмов?', '');
personalMovieDB.movies.scoreLastMovie = prompt('На сколько оцените его?', '');



// -------------------- lesson 11 (19) -------------------- 
// Условия

if (4 == 9) {
    console.log('ok');
} else {
    console.log('error');
}

// Вложенные условия

const num = 50;
if (num < 49) {
    console.log('error');
} else if (num > 100) {
    console.log('too much');
} else {
    console.log('okay');
}

// Тернарный оператор
// Если условие (num === 50) выполнилось, 
// то идет действие в случае правдивого условия : пишем действие, которое выполнится, 
// если (num === 50) не выполнилось
(num === 50) ? console.log('okay') : console.log('error');

// switch (конструкция идет на СТРОГОЕ сравнение)
// Можно работать и со строками '49'
switch (num) {
    case 49:
        console.log('no');
        break;
    case 100:
        console.log('no');
        break;
    case 50:
        console.log('yes');
        break;
    default:
        console.log('not today');
        break;
}

// -------------------- lesson 12 (20) -------------------- 

// Логические операторы

// Оператор И (&&) (ПРИМ 1)

const hamburger = true,
    fries = true;

if (hamburger && fries) {
    console.log('yum')
}

console.log((hamburger && fries));

// Поменяем пример с количеством (динамическая типизация -- переход одного типа данных в другой, 
// строка может стать числом и наоборот; что угодно может стать логическим значением)

const hamburger1 = 5,
    fries1 = 0;

if (hamburger1 && fries1) {
    console.log('yum')
}

console.log((hamburger1 && fries1));

/*
5 сущностей, которые всегда будут false:
1) 0
2) "" (пустая строка БЕЗ пробела внутри)
3) null
4) undefined
5) NaN

*/

// Усложним пример с гамбургером. 3 человека заходят в заведение
// Каждый хочет съесть по 1 гамбургеру, но один человек захочет И картошку

// Решение

const hamburger2 = 2,
    fries2 = 1;

if (hamburger2 === 3 && fries2) { // Можно записать 'fries2 === 1' or 'fries2 >= 1', 'fries' тоже подойдет
    console.log('yum')
} else {
    console.log('not yum, we are leaving')
};

console.log((hamburger2 && fries2));

/* 
Когда мы запускали ПРИМ 1 с true/false, в консоли мы получали true/false. Однако если вывести в консоль

const hamburger3 = 3,
      fries3 = 1,
      cola3 = 0;

console.log((hamburger3 === 3 && cola && fries3));

Вывод консоли -- 0. Логические операторы (Оператор 'И' &&) возвращают в консоль первое ложное значение,
на котором они остановились. Если все значения правдивы -- вывод в консоль последнего значения.

----- (И запинается на лжи, ИЛИ запинается на правде :) ) -----

Для практики можно создавать бесконечное количество примеров с алгеброй логики

ПОВТОРИМ, что в JS есть 5 сущностей, которые всегда будут false:
1) 0
2) "" (пустая строка БЕЗ пробела внутри)
3) null
4) undefined
5) NaN

То есть:
console.log(0 && 5); -- вывод 0, 0 это неправда, выводим первое, на чем "споткнулись"
console.log(null && 'fgdnfdlgkfd'); -- вывод null, null это неправда, выводим первое, на чем споткнулись
console.log(1 && 5); -- вывод 5, оба числа правдивы, выводим последнее
console.log('fdijfidjdfjd' && 0); -- вывод 0, 0 это неправда, выводим первое, на чем "споткнулись"

*/

// Комбинации операторов
// Пример: то же заведение, необходимо:
// ИЛИ 3 гамбургера И 2 колы ИЛИ 3 картошки фри И хотя бы 1 порция наггетсов

const hamburger4 = 3,
    cola4 = 3,
    fries4 = 0,
    chickenNuggets4 = 2;

if ((hamburger4 === 3 && cola4 == 2) || (fries4 === 3 && chickenNuggets4)) {
    console.log('nice');
} else {
    console.log('not good')
};

// Вывод в консоль 'nice'
// Если console.log((hamburger4 === 3 && cola4 == 2) || (fries4 === 3 && chickenNuggets4)); -- вывод 2

// Оператор 'НЕ'
// Аргумент превращается в логический тип данных (true/false), затем возвращает противоположное значение
// То есть console.log(!0); -- '0' это 'false', отрицание 'false' --> 'true', вывод в консоль 'true'

// ------------------------------ Homework #3 ------------------------------

// #1. Что выведется в консоль (логические выражения)?

console.log(NaN || 2 || undefined); // 2

console.log(NaN && 2 && undefined); // NaN

console.log(1 && 2 && 3); // 3

console.log(!1 && 2 || !3); // false

console.log(25 || null && !3); // 25

console.log(NaN || null || !3 || undefined || 5); // 5

console.log(NaN || null && !3 && undefined || 5); // 5

console.log(5 === 5 && 3 > 1 || 5); // true

// Последний пример эквивалентен данному примеру ниже, так как правая часть (до оператора ИЛИ -- true)
// Вывод в консоль первой правды, то есть -- 'true'

console.log(true || 5);


// #2. Выполняется ли условие?

const hamburger5 = 3;
const fries5 = 3;
const cola5 = 0;
const nuggets5 = 2;

if (hamburger5 === 3 && cola5 || fries5 === 3 && nuggets5) {
    console.log('Done!')
}

// Да
// false || true -- true

// #3. Выполняется ли условие?

let hamburger6;

/* 
Переменная hamburger задана через let, так как const подразумевает 
какое-либо начальное значение. С 'const' будет ошибка, можете проверить.
А без значения там undefined
*/

const fries6 = NaN;
const cola6 = 0;
const nuggets6 = 2;

if (hamburger6 || cola6 || fries6 === 3 || nuggets6) {
    console.log('Done!')
}

// Да

// #4. Выполняется ли условие?

let hamburger7;
const fries7 = NaN;
const cola7 = 0;
const nuggets7 = 2;

if (hamburger7 && cola7 || fries7 === 3 && nuggets7) {
    console.log('Done!')
}

// Нет

// -------------------- lesson 13 (21) -------------------- 

// Циклы

// Цикл while -- пока (условие) -- делай то-то

let number13 = 50;
while (number13 < 55) {
    console.log(number13);
    num++;
}

// Цикл do --  цикл что-то делает, а потом проверяет условие, если необходимо - выйдет из цикла

do {
    console.log(number13);
    num++;
}
while (number13 < 55);

// Цикл for

for (let i = 1; i < 10; i++) {
    if (i === 6) {
        break;
        // continue;
    }
    console.log(i);
}
// -------------------- lesson 14 (22) -------------------- 

// Цикл в цикле и метки

for (let i = 0; i < 3; i++) {
    console.log(i);
    for (let j = 0; j < 3; j++) {
        console.log(j);
    }
}

// При помощи циклов сделать треугольник с использованием астериска (*)
// *
// **
// ***
// ****
// *****
// ******

let res = '';
const length = 7;

for (let i = 1; i < length; i++) {
    for (let j = 0; j < i; j++) {
        res += '*';
    }
    res += '\n';
}

console.log(res);


// Как из внутреннего цикла перейти к следующему, минуя остаточные итерации?

mark: for (let i = 0; i < 3; i++) {
    console.log('first: ${i}');
    for (let j = 0; j < 3; j++) {
        console.log('second: ${j}');
        for (let k = 0; k < 3; k++) {
            if (k === 2) continue mark; // метка работает и с 'break'
            console.log('third: ${k}');
        }
    }
}


// ------------------------------ Homework #4 ------------------------------

/*Задачи:

1) При помощи цикла выведите числа от 5 до 10 в консоль. 
5 и 10 включительно. Цикл можно использовать любой

2) При помощи цикла for вывести числа от 20 до 10 в консоль. 
В обратном порядке (20, 19, 18...). Когда цикл дойдет до числа 
13 - остановить весь цикл

3) При помощи цикла for выведите чётные числа от 2 до 10 включительно

4) Перепишите цикл  for на вариант с while. Результат должен 
остаться точно таким же. Не создайте бесконечный цикл! 
Иначе браузер может зависнуть. 

Цикл, который нужно переписать:
 
for (let i = 2; i <= 16; i++) {
    if (i % 2 === 0) {
        continue;
    } else {
        console.log(i);
    }
}

5) Заполните массив цифрами от 5 до 10 включительно. Помните, что 
элементы массива можно сформировать так же, как и обращаться к ним: arr[0]

*/

// Решение
// При помощи цикла выведите числа от 5 до 10 в консоль. 
// 5 и 10 включительно. Цикл можно использовать любой

// Место для первой задачи
function firstTask() {
    // Пишем решение вот тут
    for (let i = 5; i < 11; i++) {
        console.log(i);
    }

}

// 2) При помощи цикла for вывести числа от 20 до 10 в консоль. 
// В обратном порядке (20, 19, 18...). Когда цикл дойдет до числа 
// 13 - остановить весь цикл

// Место для второй задачи
function secondTask() {
    // Пишем решение вот тут
    for (let i = 20; i > 9; i--) {
        if (i === 13) break
        else {
            console.log(i);
        }
    }

}

// 3) При помощи цикла for выведите чётные числа от 2 до 10 включительно

// Место для третьей задачи
function thirdTask() {
    // Пишем решение вот тут
    for (let i = 2; i < 11; i++) {
        if (i % 2 == 0) {
            console.log(i);
        }
    }

}

// Место для четвертой задачи

// 4) Перепишите цикл  for на вариант с while. Результат должен 
// остаться точно таким же. Не создайте бесконечный цикл! 
// Иначе браузер может зависнуть. 


// Цикл, который нужно переписать:

// for (let i = 2; i <= 16; i++) {
//     if (i % 2 === 0) {
//         continue;
//     } else {
//         console.log(i);
//     }
// }

function fourthTask() {
    // Пишем решение вот тут
    let i = 2;
    while (i <= 16) {
        if (i % 2 === 0) {
            i++;
            continue;
        } else {
            console.log(i);
            i++;
        }
    }

}

// Место для пятой задачи

// 5) Заполните массив цифрами от 5 до 10 включительно. Помните, что 
// элементы массива можно сформировать так же, как и обращаться к ним: arr[0]

/* 
P.S. В задаче не сказано об этом, однако при записи данных в массив при помощи
arrayOfNumbers[i] = i; возникает 5 пустых элементов в начале, что неверно
Поэтому [i] заменяем на [i - 5]
*/

function fifthTask() {
    const arrayOfNumbers = [];

    // Пишем решение вот тут
    for (let i = 5; i < 11; i++) {
        arrayOfNumbers[i - 5] = i;
        console.log(arrayOfNumbers);
    }


    // Не трогаем
    return arrayOfNumbers;
}


// ------------------------------ Homework #5 ------------------------------

/*Задачи:

1) Заполните новый массив (result) числами из старого (arr). 
Количество элементов в массиве можно получить как 
arr.length, а к элементам обращаемся все так же: 
arr[0], arr[1] и тд.
Должен получиться точно такой же массив

2) Измените данный массив так, чтобы все числа 
были увеличены в 2 раза, а если попадается 
строка - то к ней было добавлено " - done".
Для определения типа данных используйте typeof();
Должно получиться: [ 10, 20, 'Shopping - done', 40, 'Homework - done' ]

3) Разверните массив data наоборот при помощи цикла 
и запишите данные в массив result.
Должно получиться: [ 'Homework', 20, 'Shopping', 10, 5 ]
*/

// Решение

// Место для первой задачи
function firstTask() {
    // Значения массива менять нельзя, тут он проверяется автоматически именно на эти значения
    const arr = [3, 5, 8, 16, 20, 23, 50];
    const result = [];

    // Пишем решение вот тут
    for (let i = 0; i < arr.length; i++) {
        result[i] = arr[i];

    }
    console.log(result);
    // Не трогаем
    return result;
}

// Место для второй задачи

/* 2) Измените данный массив так, чтобы все числа 
были увеличены в 2 раза, а если попадается 
строка - то к ней было добавлено " - done".
Для определения типа данных используйте typeof();
Должно получиться: [ 10, 20, 'Shopping - done', 40, 'Homework - done' ] */

function secondTask() {
    // Значения массива менять нельзя, тут он проверяется автоматически именно на эти значения
    const data = [5, 10, 'Shopping', 20, 'Homework'];

    // Пишем решение вот тут
    for (let i = 0; i < data.length; i++) {
        if (typeof (data[i]) === 'number') {
            data[i] = data[i] * 2;
        } else {
            if (typeof (data[i]) === 'string') {
                data[i] = data[i] + ' - done';
            }
        }
    }
    console.log(data);
    // Не трогаем
    return data;
}

/* 
3) Разверните массив data наоборот при помощи цикла 
и запишите данные в массив result.
Должно получиться: [ 'Homework', 20, 'Shopping', 10, 5 ]
*/

// Место для третьей задачи
function thirdTask() {
    // Значения массива менять нельзя, тут он проверяется автоматически именно на эти значения
    const data = [5, 10, 'Shopping', 20, 'Homework'];
    const result = [];

    // Пишем решение вот тут
    for (let i = 1; i <= data.length; i++) {
        result[i - 1] = data[data.length - i];
    }
    console.log(result);
    // Не трогаем
    return result;
}





// ПЕРЕРЕШАТЬ САМОМУ СНОВА

// 3) При помощи цикла for выведите чётные числа от 2 до 10 включительно

for (let i = 2; i < 11; i++) {
    if (i % 2 === 0) {
        console.log(i);
    }
}

// 4) Перепишите цикл  for на вариант с while. Результат должен 
// остаться точно таким же. Не создайте бесконечный цикл! 
// Иначе браузер может зависнуть. 
// Цикл, который нужно переписать:

// for (let i = 2; i <= 16; i++) {
//     if (i % 2 === 0) {
//         continue;
//     } else {
//         console.log(i);
//     }
// }

let i = 2;
while (i <= 16) {
    if (i % 2 === 0) {
        i++;
        continue;
    } else {
        console.log(i);
        i++;
    }
}

// 5) Заполните массив цифрами от 5 до 10 включительно. Помните, что 
// элементы массива можно сформировать так же, как и обращаться к ним: arr[0]

const arrayOfNumbers = [];

// Пишем решение вот тут
const result = [];
for (let i = 5; i < 11; i++) {
    result[i - 5] = i;
}
console.log(result);

// Не трогаем
return arrayOfNumbers;





/* 1) Заполните новый массив (result) числами из старого (arr). 
Количество элементов в массиве можно получить как 
arr.length, а к элементам обращаемся все так же: 
arr[0], arr[1] и тд.
Должен получиться точно такой же массив */

const arr123 = [3, 5, 8, 16, 20, 23, 50];
const result123 = [];

// Пишем решение вот тут
for (let i = 0; i < arr123.length; i++) {
    result123[i] = arr123[i];
}
console.log(result123);
// Не трогаем
return result123;

/* 2) Измените данный массив так, чтобы все числа 
были увеличены в 2 раза, а если попадается 
строка - то к ней было добавлено " - done".
Для определения типа данных используйте typeof();
Должно получиться: [ 10, 20, 'Shopping - done', 40, 'Homework - done' ] */

const data111 = [5, 10, 'Shopping', 20, 'Homework'];

// Пишем решение вот тут
for (let i = 0; i < data111.length; i++) {
    if (typeof (data111[i]) == 'number') {
        data111[i] = data111[i] * 2;
    }
    if (typeof (data111[i]) == 'string') {
        data111[i] = data111[i] + ' - done';
    }
}
console.log(data111);

// Не трогаем
return data111;

/* 
3) Разверните массив data наоборот при помощи цикла 
и запишите данные в массив result.
Должно получиться: [ 'Homework', 20, 'Shopping', 10, 5 ]
*/

const data12 = [5, 10, 'Shopping', 20, 'Homework'];
const result12 = [];

// Пишем решение вот тут
for (let i = 0; i < data12.length; i++) {
    result12[i] = data12[data12.length - 1 - i];
}
console.log(result12);
// Не трогаем
return result12;

// а если совместить две задачи вместе, получим

// первое решение
const data123 = [5, 10, 'Shopping', 20, 'Homework'];
const resULT123 = [];
for (let i = 0; i < data123.length; i++) {
    if (typeof (data123[data123.length - 1 - i]) == 'number') {
        data123[data123.length - 1 - i] = data123[data123.length - 1 - i] * 2;
    }
    if (typeof (data123[data123.length - 1 - i]) == 'string') {
        data123[data123.length - 1 - i] = data123[data123.length - 1 - i] + ' - done';
    }
    resULT123[i] = data123[data123.length - 1 - i];
}
console.log(resULT123);

// второе решение

const dat = [5, 10, 'Shopping', 20, 'Homework'];
const resul = [];
for (let i = 0; i < dat.length; i++) {
    resul[i] = dat[dat.length - 1 - i];
    if (typeof (resul[i]) == 'number') {
        resul[i] = resul[i] * 2;
    }
    if (typeof (resul[i]) == 'string') {
        resul[i] = resul[i] + ' - done';
    }
}
console.log(resul);

// задача **
// сделать елочку из звезд (астериск)

// При помощи циклов сделать треугольник с использованием астериска (*)
//      *
//     ***
//    *****
//   *******
//  *********
// ***********

const heightSpruce = 9;
let resultSpruce = '';

for (let i = 0; i < heightSpruce; i++) {
    for (let j = heightSpruce; j > (i + 1); j--) {
        resultSpruce += ' ';
    }
    for (let k = 0; k < (2 * i + 1); k++) {
        resultSpruce += '*';
    }
    resultSpruce += '\n';
}
console.log(resultSpruce);


const heightSpruce1 = 9;
let resultSpruce1 = '';

for (let i = 0; i < heightSpruce; i++) {
    resultSpruce1 += ' '.repeat(heightSpruce1 - i - 1) + '*'.repeat(2 * i + 1) + '\n';
}

console.log(resultSpruce1);

// -------------------- lesson 15 (23) -------------------- 

/*
file 'practice2.js'
*/


// -------------------- lesson 16 (24) -------------------- 
// функции, стрелочные функции
// Функции - наши действия в JS. Они используют различные типы данных, изменяют
// информацию так, как мы укажем. Также сокращает код как цикл

// Название функции должно быть глаголом с припиской того, над чем выполняется действие

function showFirstMessage() {
    console.log('hi');
}
showFirstMessage();

// Аргументы записываются в круглых скобках

function showFirstMessage(text, arg) {
    console.log(text);
}
showFirstMessage('hi');

// Если мы объявляем переменную внутри функции, снаружи функции она уже недоступна
// Такая переменная называется локальной, так как существует только внутри функции:

/* 
function showFirstMessage(text) {
    console.log(text);
    let numberic = 20;
}
showFirstMessage('hi');
console.log(numberic); -- numberic is nit defined
*/

// Однако можно использовать глобальную переменную внутри функции:

/* 
let numberic = 30;
function showFirstMessage(text) {
    console.log(text);
    numberic = 20; (можно дописать let, тогда обращение будет к глобальной и выведится 30)
}
showFirstMessage('hi');
console.log(numberic); -- numberic is nit defined
*/

// !!!!!!!!!!!!!!! Замыкание !!!!!!!!!!!!!!!

/*
let numberic = 30;
function showFirstMessage(text) {
    console.log(text);
    let numberic = 20; 
    console.log(numberic);
}
showFirstMessage('hi');
console.log(numberic);

-----> Выведется два числа. 20 и 30 <-----

let numberic = 30;
function showFirstMessage(text) {
    console.log(text);
    console.log(numberic);
}
showFirstMessage('hi');
console.log(numberic);

Что же происходит, когда программа выполняет функцию? Несколько шагов:

1) JavaScript создаёт новую область выполнения — локальную область выполнения.
2) Локальная область выполнения имеет свой набор переменных, 
которые будут локальными для этой области выполнения.
3) Новая область выполнения передаётся в стек выполнения. 
Думайте о стеке выполнения, как о механизме слежения за ходом исполнения программы.

-----> когда начнется выполнение строки console.log(numberic); внутри функции,
внутри функции не будет переменной numberic. В таком случае
функция будет искать переменную на 1 уровень выше (нашу глобальную, равную 30)
Если и на нем нет -- идет до самого высшего уровня, который ей доступен <-----

Глобальный код — обычное окружение, в котором ваш код выполняется изначально.
Код функции — всякий раз, когда поток выполнения попадает в тело функции.


Замыкание функций -- это сама функция вместе со всеми внешними переменными, которые ей доступны
*/

// return -- позволяет вернуть во "внешний мир" из функции:

function calc(a, b) {
    return (a + b);
    console.log(4, 3) // unreachable code -- мертвый код, который никогда не выполнится
    // Поэтому после return мы ничего не задаем
}
console.log(calc(4, 3));
console.log(calc(228, 337));
console.log(calc(25, 52));

function retURN() {
    let num = 50;
    return num;
}
const anotherNum = retURN();
console.log(anotherNum);


// Классификация функций

// 1) function declaration -- создается до начала выполнения скрипта, можно вызвать перед объявлением (схожесть с 'var')
// то, что было использовано выше

/* function example() {
 code
 } 
 
То есть можно спокойно сделать вот так (вывести значение функции до объявления функции)
Можно помещать все созданные функции вниз страницы, а сверху -- использовать их

console.log(calc(4, 3));
console.log(calc(228, 337));
console.log(calc(25, 52));

function calc(a, b) {
    return(a + b);
}

 
 */

// 2) function expression (функциональное выражение) -- создается только тогда, 
// когда доходит поток кода, можно вызвать ТОЛЬКО после объявления

/* let logger = function() {
 console.log('hello')
 }; 

 logger();

!!! ОБЯЗАТЕЛЬНО В КОНЦЕ ПОСТАВИТЬ ТОЧКУ С ЗАПЯТОЙ, В FUNCTION DECLARATION НЕ НУЖНО !!!
*/

// 3) Стрелочные функции () => -- не имеет своего контекста (this)

const calc = (a, b) => a + b; // упрощенный вариант

const calc = (a, b) => { return a + b }; // классический для многострочной структуры

// -------------------- lesson 17 (25) -------------------- 

// Аргументы функции

const usdRate = 28;
const eurRate = 32;

function convert(amount, rate) {
    console.log(rate * amount);
}
convert(500, usdRate);
convert(500, eurRate);

// -------------------- lesson 18 (26) --------------------

// важность return

// если полученное значение понадобится дальше -- требуется return

const usdCurrently = 28;
const eurCurrently = 32;
const discount = 0.9;

function convert(amount, currently) {
    return currently * amount;
}

function promotion(result) {
    console.log(result * discount)
}

convert(500, usdCurrently);
convert(500, eurCurrently);
promotion(convert(500, usdCurrently)); // функция внутри функции может быть не практично
// тогда:
const resss = convert(500, usdCurrently);
promotion(resss);


// после return может быть возвращено любое значение -- число, объект, массив, другая функция
// в основе приема компонента высшего порядка лежит то, что функция возвращает другую функцию
// example: return function() {}

// прекращение работы функции 

function text() {
    for (let i = 0; i < 5; i++) {
        console.log(i);
        if (i === 3) { return }
    }
    console.log('done');
}

test();

// что же будет возвращать function? undefined
// любая функция что-то возвращает, если ничего не задано -- undefined. проверим это:

function doNothing() { };
console.log(doNothing() === undefined);

// вывод 'true', нет фактически заданного return -- вывод undefined

// почему в консоли в браузере при выполнении когда мы когда-нибудь можем увидеть undefined?
// откроем консоль, напишем 'console.log('10');
// выведется 10 и ниже undefined.
// console.log -- функция, console -- Объект, .log -- метод (функция записанная внутри объекта)
// так будет вести себя любая функция, не содержащая return {smth}

// после return не ставьте перенос строки!
// JS автоматически подставит ; после return, следовательно все что ниже - unreachable (недостижимо)

// Итог: если функция должна вернуть какой-то результат для дальнейшей работы - пригодится return
// Также всегда можно досрочно закончить функцию, используя return


// ------------------------------ Homework #6 (после урока 26) ------------------------------

/*
1) Создайте функцию, которая будет на вход принимать 1 аргумент с именем человека и возвращать строку.

Пример: вызов функции sayHello('Антон') возвращает строку "Привет, Антон!". В решении вызывать функцию не 
нужно, программа сделает это за вас.

P.S. возвращать - это использовать ключевое слово return.
P.S.S. Это классическая функция-модификатор, которых мы дальше по курсу будем создавать еще много в разных видах.
*/

// Решение

function sayHello(name) {
    return `Привет, ${name}!`;
}
sayHello('Artem');
console.log(sayHello('Artem'));

/*
2) Создайте функцию, которая принимает в себя 1 аргумент в виде целого числа и возвращает массив из трех чисел: 
одно на 1 меньше, сам аргумент, и число на 1 больше.

Пример: вызов функции returnNeighboringNumbers(5) возвращает массив в виде [4, 5, 6].
*/

// Решение
function returnNeighboringNumbers(massive) {
    return [massive - 1, massive, massive + 1]
}

console.log(returnNeighboringNumbers(-100));

/* 3) Создайте функцию, которая будет принимать в себя 2 аргумента, оба числа. Первое число - это база, 
второе число - это сколько раз нужно будет повторить это число в прогрессии. (Смотри пример ниже). 
Функция должна возвращать строку (или число в особых случаях, о которых ниже), где эти числа идут по 
порядку, разделенные тремя дефисами "---". После последнего числа их не должно быть.

Если второй аргумент не является числом, равен или меньше нуля - то возвращать просто первый аргумент. 
(Проверяем через оператор typeof)

Примеры:

Вызов функции getMathResult(5, 3) даст ответ 5---10---15

Вызов функции getMathResult(3, 10) даст ответ 3---6---9---12---15---18---21---24---27---30

Вызов функции getMathResult(10, 5) даст ответ 10---20---30---40---50

Вызов функции getMathResult(10, '5') даст ответ 10

Вызов функции getMathResult(10, 0) даст ответ 10

Вызов функции getMathResult(20, -5) даст ответ 20

Эта задача уже ближе к реальности, когда вам нужно учитывать и тип данных у аргументов, 
проверять их и продумывать логику работы внутри. Обратите внимание на прогрессию, 
она рассчитывается по простой формуле умножения. Если первый аргумент 5, а второй 3, 
то число повторяется 3 раза, каждый раз увеличиваясь на само себя. 
Это базовая математика, которая и нужна для работы в 95% случае на фронтенде.
*/

function getMathResult(num, times) {
    if (times <= 0 || typeof (times) !== 'number') {
        return num;
    }
    let stringer = '';
    for (let i = 1; i <= times; i++) {
        if (i === times) {
            stringer += `${num * i}`;
        } else {
            stringer += `${num * i}---`;
        }
    }
    return (stringer);
}
console.log(getMathResult(10, 5));



// -------------------- lesson 19 (27) --------------------

// Методы и свойства у строк и чисел
// Методы -- вспомогательные функции, свойства -- вспомогательные значения

const str = 'test';
console.log(str.length); // свойство -- Количество символов в строке, 

const arr = [1, 2, 3, 4, 5, 10];
console.log(arr.length); // свойство кол-во элементов внутри массива
// Свойство не вызывается, пишется через точку
// Методы, которые будут вспомогательными функциями уже вызываются при помощи ()

// все методы и свойства можно найти на MDN -- тип данных string, слева функции и свойства
// или браузером -- console.dir(Number);

// Можно указать конкретный элемент в строке:
console.log(str[2]); // вывод 's' -- 3 символ по порядку
// При попытке заменить символ в строке -- ничего не выйдет
console.log(str[2] = 'd'); // вывод 'd'
console.log(str); // вывод 'test'
// Напрямую нельзя изменить строку (отрезать часть строки, заменить символ). Для этого есть методы

// Метод изменения регистра
console.log(str.toUpperCase()); // вывод 'TEST', так как содержит новое значение
// Напрямую не изменяет начальную строку
console.log(str.toLowerCase());
console.log(str); // вывод 'test'

// Метод, который позволяет найти кусок строки и указать, с какой позиции он начинается (поиск подстроки)

const fruit = 'Some fru fruit'
console.log(fruit.indexOf('fruit'));
// Значение '-1' дает понять, что такой строки не было найдено
// Если строка неизменяема, как мы сможем ее изменить?

// 3 метода взаимодействия со строками

const logg = 'Hello world';
console.log(logg.slice(6, 11)); // Второй аргумент не включительно
console.log(logg.slice(6)); // с 6 символа до конца
console.log(logg.slice(-5, -1)); // Отсчет справа

// метод substring -- похож на предыдущий, разница в том, что 1 аргумент можно задать больше чем 2
// substring не поддерживает отрицательные значения

// метод substr -- вместо 2 аргумента конца мы указываем длину, которую хотим вырезать из строки

// методы для чисел -- для работы с числами есть отдельная библиотека Math

const numBERRR = 12.2;
console.log(Math.round(numBERRR));


const test = '12.2px';
console.log(parseInt(test)); // Перевод числа в другую СС, получим 12 -- числовой тип данных
// применение метода не по назначению, но почему бы и нет
console.log(parseFloat(test)); // Возврат числа с плавающей точкой

// ------------------------------ Homework #7 (после урока 28) ------------------------------

/*
1) Создайте функцию, которая будет вычислять объем и площадь полной поверхности куба 
(тоже базовая математика, иногда используется в создании анимаций). 
Эта функция принимает в себя целое число со значением длины ребра куба. 
Ответ выведите в формате строки, который изображен в примерах.

Если в функцию попал неправильный аргумент или вычислить значения невозможно - 
вернуть строку "При вычислении произошла ошибка"

НЕ ИСПОЛЬЗУЙТЕ ОПЕРАТОР СТЕПЕНИ ** - в онлайн среде браузера он не работает и тесты будут ломаться. 
Это из-за того, что этот оператор из более нового стандарта, чем тут доступен.

Примеры:

calculateVolumeAndArea(5)  => 'Объем куба: 125, площадь всей поверхности: 150'

calculateVolumeAndArea(15)  => 'Объем куба: 3375, площадь всей поверхности: 1350'

calculateVolumeAndArea(15.5)  => 'При вычислении произошла ошибка'

calculateVolumeAndArea('15')  => 'При вычислении произошла ошибка'

calculateVolumeAndArea(-15)  => 'При вычислении произошла ошибка'
*/

function calculateVolumeAndArea(i) {
    if (typeof (i) !== 'number' || i < 0 || !Number.isInteger(i)) {
        return "При вычислении произошла ошибка"
    }

    let Volume = 0;
    let Area = 0;

    Volume = i * i * i;
    Area = i * i * 6;

    return `Объем куба: ${Volume}, площадь всей поверхности: ${Area}`;
}

calculateVolumeAndArea(5);
console.log(calculateVolumeAndArea(5));
/*
2) Постепенно переходим к более реалистичным задачам :) Вы обнаружите, что там используется все тоже самое.

Напишите функцию, которая будет определять номер купе по переданному ей номеру места.

1, 2, 3, 4 -- 1
5, 6, 7, 8 -- 2
9, 10, 11, 12 -- 3
13, 14, 15, 16 -- 4
17, 18, 19, 20 -- 5
21, 22, 23, 24 -- 6
25, 26, 27, 28 -- 7
29, 30, 31, 32 -- 8
33, 34, 35, 36 -- 9

Функция принимает только целое число от 1 до 36.

Если переданный аргумент не число, отрицательное или дробное - возвращается сообщение:

"Ошибка. Проверьте правильность введенного номера места"

Если число 0 или больше 36, то сообщение: "Таких мест в вагоне не существует"

Пример:

getCoupeNumber(33)  => 9

getCoupeNumber(7)  => 2

getCoupeNumber(300)  => "Таких мест в вагоне не существует"

getCoupeNumber(0)  => "Таких мест в вагоне не существует"

getCoupeNumber(7.7)  => "Ошибка. Проверьте правильность введенного номера места"

getCoupeNumber(-10)  => "Ошибка. Проверьте правильность введенного номера места"

getCoupeNumber('Hello')  => "Ошибка. Проверьте правильность введенного номера места"

Такая функция вполне реальна и может использоваться для 
формирования билетов, в том числе и визуально на сайтах. 
Конечно, там будет куда больше условий, но смысл остается таким же.
*/

function getCoupeNumber(i) {
    if (i === 0 || i > 36) {
        return "Таких мест в вагоне не существует"
    }
    if (typeof (i) !== 'number' || !Number.isInteger(i) || i < 1) {
        return "Ошибка. Проверьте правильность введенного номера места"
    }

    return Math.ceil(i / 4);

}
getCoupeNumber(5);
console.log(getCoupeNumber(5));

// ------------------------------ Homework #8 (после урока 28) ------------------------------

/*
1) Создайте функцию, которая принимает в себя целое число 
минут и возвращает время в нужном формате строки. 
(Смотри пример). Обратите внимание на окончание слова "час" - 
оно меняется в зависимости от цифры. Если вместо аргумента приходит не число, 
дробное или отрицательное число - функция возвращает строку "Ошибка, проверьте данные"

Внимание! Давайте пока ограничимся максимум 600ю минутами (10 часов). 
Так как проверки на большие числа будут раздувать код (33 часа, 31 час, 11 часов и тд). 
Этого будет достаточно и код будет проверять именно этот промежуток (1 - 10 часов). 
Но вы можете реализовать и полный скрипт, он тоже должен проходить тесты.

Пример:

getTimeFromMinutes(150) => "Это 2 часа и 30 минут"

getTimeFromMinutes(50) => "Это 0 часов и 50 минут"

getTimeFromMinutes(0) => "Это 0 часов и 0 минут"

getTimeFromMinutes(-150) => "Ошибка, проверьте данные"
*/

function getTimeFromMinutes(minutes) {
    if (typeof minutes !== 'number' || !Number.isInteger(minutes) || minutes < 0) {
        return "Ошибка, проверьте данные";
    }

    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;

    let hoursText;
    if (hours % 10 === 1 && hours % 100 !== 11) {
        hoursText = 'час';
    } else if (hours % 10 >= 2 && hours % 10 <= 4 && (hours % 100 < 10 || hours % 100 >= 20)) {
        hoursText = 'часа';
    } else {
        hoursText = 'часов';
    }

    let minutesText;
    if (mins % 10 === 1 && mins % 100 !== 11) {
        minutesText = 'минута';
    } else if (mins % 10 >= 2 && mins % 10 <= 4 && (mins % 100 < 10 || mins % 100 >= 20)) {
        minutesText = 'минуты';
    } else {
        minutesText = 'минут';
    }

    return `Это ${hours} ${hoursText} и ${mins} ${minutesText}`;
}
getTimeFromMinutes(5228);
console.log(getTimeFromMinutes(60060));
/*
2) Напишите функцию, которая принимает в себя 4 числа и 
возвращает самое большее из них. 
Если один из аргументов не является числом или их меньше 
4 - возвращается 0. Дробные числа разрешены.

Пример:

findMaxNumber(1, 5, 6.6, 11); =>  11

findMaxNumber(1, 5, '6', '10');  =>  0

У этой задачи есть очень много вариантов решения, в том числе и встроенное в JS. Подходит любое :)
*/

function findMaxNumber(a, b, c, d) {
    if (typeof (a) !== 'number' || typeof (b) !== 'number' || typeof (c) !== 'number' || typeof (d) !== 'number') {
        return 0;
    } else { return Math.max(a, b, c, d); }
}

// ------------------------------ Homework #9** (после урока 28) ------------------------------

/*
Создайте функцию, которая будет принимать в себя один аргумент-целое положительное число. 
Она должна возвращать строку, в которой будут через пробел выведены числа Фибоначчи. 
Причем, их количество должно быть равно переданному аргументу.

Если переданный аргумент не число - вернуть пустую строку. Решать без применения рекурсии.

Пример:

fib(4) => ''0 1 1 2"

fib(7) => ''0 1 1 2 3 5 8"

fib('7') => ''"

fib(1) => "0"

fib(0) => ''"
*/

// 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55...
// F(n) = F(n-1) + F(n-2), где F(0) = 0, F(1) = 1 для n >= 2

function fib(number) {
    if (typeof (number) !== 'number' || number <= 0 || !Number.isInteger(number)) {
        return '';
    }
    let result = '';
    let first = 0;
    let second = 1;
    for (let i = 0; i < number; i++) {
        if (i + 1 === number) {
            result += `${first}`;
        } else { result += `${first} ` }
        let third = first + second;
        first = second;
        second = third;
    }
    return result;
}
console.log(fib(0));
console.log(fib(1));
console.log(fib(2));


function fib(n) {
    return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

console.log(fib(7));




// -------------------- lesson 20 (28) --------------------

// метод trim()
// позволяет удалять пробельные символы с начала и конца строки 
// (пробел, табуляция, неразрывный пробел и пр. + с конца LF, CR, пр.)
const lastMovieYouWatched1 = prompt('Один из последних просмотренных фильмов?', '').trim();

let orig = "   foo  ";
console.log(orig.trim()); // 'foo'
// доп проверка преобразования ответа от пользователя (' ' -- не пустая строка!!!)

// -------------------- lesson 21 (29) --------------------

// callback-функции
// функция, которая должна быть выполнена после того, как другая функция завершила свое выполнение

function first() {
    // do smth
    setTimeout(function () {
        console.log(1);
    }, 500);
}

function second() {
    console.log(2);
}

first();
second();

// в данном коде вывод: 2 1
// мы хотим, чтобы вывод совпадал с вызовом функций, т.е чтобы вывод был '1 2'
// используем callback

function learnJS(lang, callback) {
    console.log(`я учу: ${lang}`);
    callback();
} // Шаблон функции

learnJS('JavaScript', function () {
    console.log(`я прошел урок`);
}); // анонимная функция, обращение одноразовое
/* аргумент функции: 
function() { console.log(`я прошел урок`); }
*/

// передадим осознанную функцию:

function done() {
    console.log(`я прошел урок`);
}

learnJS('JavaScript', done); // не вызываем функцию, а передаем
// чтобы в дальнейшем она была использована

// соблюдается последовательность функций

// callback нужны для событий, которые происходят на странице
// когда пользователь кликнул -- передаем callback, который выполняется строго после клика


// callback позволяют быть уверенными в том, что определенный код не начнет исполнение до того момента
// пока другой код не завершит свое исполнение


// -------------------- lesson 22 (31) --------------------

// Объекты. Методы объектов. Деструктуризация объектов
// Объекты -- ассоциативные массивы

const obj31 = new Object(); // Обычно не пользуются данным способом
const options = {
    name: 'test', // ключ/значение (свойство/значение)
    width: 1024,
    height: 1024,
    colors: {
        border: 'black',
        background: 'red',
        bgg: 'yellow',
        bg: 'blue'
    }
};
console.log(options.name);
console.log(options['name']);
console.log(options['colors']['border']);
// Если необходимо удалить свойство из объекта:
delete options.name;

// ПРЯМЫХ КОНСТАНТ В JS НЕ СУЩЕСТВУЕТ

for (let key in options) { // способ перебора всех свойств объекта 'for in'
    if (typeof (options[key]) == 'object') { // fix вывод colors: obj obj
        for (let i in options[key]) {
            console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
        }
    } else {
        console.log(`Свойство ${key} имеет значение ${options[key]}`);
    }
} //перебор свойств объекта
// есть 'for of' (не работает для объектов)

// функции и методы, которые есть внутри объекта (документация -- object), свойства, методы

// нет свойства length. реализуем его

let counter = 0;

for (let key in options) { // способ перебора всех свойств объекта 'for in'
    if (typeof (options[key]) == 'object') { // fix вывод colors: obj obj
        for (let i in options[key]) {
            console.log(`Свойство ${i} имеет значение ${options[key][i]}`);
            counter++; // если хотим вести подсчет на верхнем уровне (в главном объекте), убираем эту строку
        }
    } else {
        console.log(`Свойство ${key} имеет значение ${options[key]}`);
        counter++;
    }
}
console.log(counter);

// классический метод подсчета количества свойств в объекте:

let counter1 = 0;
for (let key in options) {
    counter1++;
}
console.log(counter1);

// методы объектов, встроенные в JS

// используем вместо счетчика
console.log(Object.keys(options)); // берет объект, создавая массив, состоящих их ключей на верхнем уровне
// можем использовать свойство length, чтобы узнать количество элементов
console.log(Object.keys(options).length);

// Можно создавать методы вручную, так как метод -- действие, которое умеет совершать объект:


const options31 = {
    name: 'test', // ключ/значение (свойство/значение)
    width: 1024,
    height: 1024,
    colors: {
        border: 'black',
        background: 'red',
    },
    makeTest: function () { // первый метод внутри объекта, созданный самостоятельно
        console.log('test');
    }
};

options31.makeTest(); // Запуск. '()' означают, что что-то идет в работу (функция, метод)

// Объекты -- (ассоциативные массивы) структуры, которые могут сохранять в себе любые типы данных в формате ключ:значение
// Объекты могут быть вложенными -- объект/массив, массив/объект, объект/объект, массив/массив
// Для их перебора можем использовать 'for in'
// У объектов бывают встроенные методы и свойства, которые необходимо использовать
// Чтобы объект что-то мог выполнять, можно записать внутри него функции, создавая методы объекта

// Свойства accessory (геттеры, сеттеры (get/set), дескрипторы)


// Деструктуризация объектов (относится и к массивам)
// При необходимости вызова нужного вложенного свойства не нужно использовать такую конструкцию:
// console.log(options['colors']['border']);
// Используем деструктуризацию объекта (в качестве отдельных структур):

const { border, background } = options31.colors; // Деструктуризация (вытащили свойство в качестве отдельной переменной)
console.log(border);

/* Как устроен JS изнутри. Все что существует в языке так или иначе идет от объектов
Например используем метод toUpperCase. Откуда у обычной строки появляется метод, который что-то выполняет?
Строка на базовом уровне является объектом, и получает этот метод через цепочку прототипов
В консоли разработчика можно вывести console.dir(String) -- вывод строку в качестве объекта
Внутри объекта будут свойства:методы, а также свойство 'prototype', в котором содержится много методов
Все это приходит от объекта
JS -- Объектно-ориентированный язык (все сущности которые есть, сводятся к объектам). Если вдаваться в терминологию --
JS -- прототипно-ориентированный язык */
// Метод объекта в javascript -- это просто функция, которая добавлена в ассоциативный массив

// -------------------- lesson 23 (32) --------------------

// массивы и псевдомассивы. методы для работы с ними
// массив -- это структура, которая содержит элементы по порядку

const arr32 = [1, 2, 3, 4, 5, 6];

arr32.pop(); // удаляет последний элемент
arr32.push(7); // Добавляет элемент в конец массива

arr32.shift(); // удаляет элемент с начала массива
arr32.unshift(); // добавляет элемент в начало массива
// недостаток -- долгое время обработки в больших массивах,
// так как идет переназначение порядкового номера у всех элементов массива

// перебор элементов

for (let i = 0; i < arr32.length; i++) {
    console.log(arr32[i]);
}

console.log(arr32.length); // свойство 'length' связано с
// порядковым номером, оно состоит из последнего индекса массива + 1
// длина массива на 1 больше чем последний порядковый номер элемента
// то есть если добавить 'arr[99] = a', то 'length = 99+1'
// ИДЕТ НАРУШЕНИЕ ЛОГИКИ


// такой же результат

for (let value of arr32) { // можем использовать break/continue
    console.log(value);
}

// методы массивов
// метод forEach (функция, принимающая callback func) -- перебор элементов внутри массива
// принимает в себя 3 аргумента. 1 -- который мы перебираем, 2 -- номер по порядку
// 3 -- ссылка на массив, который мы перебираем

arr32.forEach(function (item, i, array) { // не можем использовать break/continue
    console.log(`${i}: ${item} внутри массива ${array}`);
});

// еще есть 4 метода перебора, НО они занимаются и методом трансформации массивов
// arr.map
// arr.every/some
// arr.filter
// arr.reduce
// arr.forEach ПРОСТО его перебирает

/*
Методы массивов:
arr.push('a') - добавляет элемент в конец массива
arr.pop() - удаляет последний элемент из массива и возвращает его
arr.shift() - удаляет из массива первый элемент и возвращает его
arr.unshift('a') - добавляет элемент в начало массива
arr.split(s) - превращает строку в массив, s - разделитель
arr.join(s) - превращает массив в строку, s - разделитель
delete arr[1] - удаляет второй элемент
arr.splice(index, count, elem1…) - удалить count элементов, начиная с index и заменить на элементы elem1…
arr.slice(begin, end) - копирует часть массив с begin до end не включая
arr.sort(fn) - сортировка массива. Если не передать функцию сравнения - сортирует элементы как строки.
arr.reverse() - меняет порядок элементов на обратный.
arr.concat(item1…) - создаёт новый массив, в который копируются элементы из arr, а также item1…
*/

// split, join, sort

// Получаем от сервера большую строку (typeof 'string'). Хотим превратить ее в массив

const str32 = prompt('', '');
const product = str32.split(', ');
console.log(product);

// Обратная операция -- join (Объединение элементов массива)

const str322 = prompt('', '');
const product2 = str322.split(', ');
console.log(product.join('; '));

// метод сортировки sort

const str3222 = prompt('', '');
const product22 = str3222.split(', ');
product.sort(); // сортировка по алфавиту как строки
// если применить метод по массиву с числами -- сортировка как строки (10, 13, 2, 26, 8)
function compareNum(a, b) { // добавим коллбэк в сортировку
    return a - b;
}
product.sort(compareNum);
console.log(product.join('; '));

// псевдомассивы
// это объект, структура которого совпадает с массивом
// в них не будет методов forEach, push, pop и тд

// -------------------- lesson 24 (34) --------------------

// Передача данных по ссылке и по значению
// Spread оператор

let a = 5;
let c = a;
c = c + 5;

console.log(c);
console.log(a);
// вывод 10 5

const object34 = {
    a: 5,
    c: 1
};

const copy = object34;
copy.a = 10;
console.log(copy);
console.log(c);
// вывод a: 10 b: 1 (дважды)
// когда мы работаем с примитивными типами данных типа строк, чисел, логических выражений
// то они передаются по значению, т.е 'b = a' a -> 5. ЭТО РАБОТАЕТ С ПРИМИТИВАМИ

// когда работаем с объектом (массивы, функции, спец. объекты) -- передача данных
// по ссылке. Строка 2149 'const copy = object34;' мы не скопировали новый объект.
// В переменную 'copy' не кладется новый объект, который идентичен структуре 'object34'.
// Мы передаем значение ПО ССЫЛКЕ. т.е запись ' = object34' передает не саму структуру,
// а именно ссылку. Модифицируя копию -- модифицируем настоящий объект через ссылку

// Как же тогда создавать копии объектов, массивов?
// Есть несколько способов
// 1: цикл клонирования объекта

function copy(mainObj) {
    let objCopy = {};

    let key;
    for (key in mainObj) {
        objCopy[key] = mainObj[key];
    }
    return objCopy;
}
const numbers = {
    a: 2,
    b: 5,
    c: {
        x: 7,
        y: 4
    }
};

const newNumbers = copy(numbers);

newNumbers.a = 10;
newNumbers.c.x = 10; // в исходном будет 10
console.log(newNumbers);
console.log(numbers);

// если протестировать код более тщательно, можно заметить 
// особенность (обращение ко внутреннему объекту 'c')
// когда происходит клонирование, бывают глубокие и поверхностные копии
// объектов. мы создали ПОВЕРХНОСТНУЮ (берет свойства из родителя)
// и создает независимые структуры. однако во ВЛОЖЕННОЙ структуре
// (объект, массив) -- это свойство будет иметь ссылочный тип данных

// 2: метод object.assign()
// соединяет несколько объектов

const added = {
    d: 17,
    e: 20
};

// соединим объект 'added' с объектом 'numbers':
console.log(Object.assign(numbers, added)); // независимая поверхностная копия объекта
// Если не считать вложенную структуру в виде свойства 'c')))
// то же самое можно сделать с пустым объектом:
console.log(Object.assign({}, added));


// 3: метод для создания копии массива

const oldArray = ['a', 'b', 'c'];
const newArray = oldArray.slice();
newArray[1] = 'abcdef';
console.log(oldArray);
console.log(newArray);

// 4: оператор разворота SPREAD для массивов (ES6) и объектов (ES8) (стандартизирован в ES9 2018)

const video = ['YT', 'vimeo', 'rutube'],
    blogs = ['wordpress', 'livejournal', 'blog'],
    internet = [...video, ...blogs, 'vk', 'telegram'];

console.log(internet);

// сделаем то же самое для объектов (spread)

const arrayyy = ['a', 'b'];
const newarrayyy = [...arrayyy];
const q = {
    one: 1,
    two: 2
};
const newObjQ = { ...q };


// ------------------------------ Homework #10 (после урока 34) ------------------------------

// упражнение по написанию кода 10. Работа с объектами
/*
1) Напишите функцию showExperience, которая будет принимать в себя 
объект со всеми данными и возвращать строку с опытом.

Пример:
showExperience(personalPlanPeter) => '1 month'

P.S. желательно использовать деструктуризацию, но не обязательно

2) Напишите функцию showProgrammingLangs, которая будет принимать в себя 
объект со всеми данными и возвращать строку в нужном виде.

Пример:
showProgrammingLangs(personalPlanPeter)  =>
"Язык js изучен на 20% Язык php изучен на 10%"

Причем функция должна работать вне зависимости от количества языков. 
Если ни один не указан, то возвращается пустая строка.
P.S. Для переноса строки используется \n в конце строки.

3) Создайте метод showAgeAndLangs внутри объекта personalPlanPeter. 
При его вызове метод будет принимать в себя объект и возвращать строку в нужном виде.
Пример:
personalPlanPeter.showAgeAndLangs(personalPlanPeter) =>
'Мне 29 и я владею языками: RU ENG'
Заметьте, что возраст и языки подставляются автоматически из объекта, 
а языки всегда в верхнем регистре (большими буквами). Если данные в объекте 
поменяются, то и сообщение тоже изменится.
*/

const personalPlanPeter = {
    name: "Peter",
    age: "29",
    skills: {
        languages: ['ru', 'eng'],
        programmingLangs: {
            js: '20%',
            php: '10%'
        },
        exp: '1 month'
    },
    showAgeAndLangs: function (plan) {
        const { age } = plan;
        const { languages } = plan.skills;
        let str = `Мне ${age} и я владею языками: `;
        languages.forEach(function (lang) {
            str += `${lang.toUpperCase()} `;
        });
        return str;
    }
};
personalPlanPeter.showAgeAndLangs(personalPlanPeter);
console.log(personalPlanPeter.showAgeAndLangs(personalPlanPeter));
/* Напишите функцию showExperience, которая будет принимать в себя 
объект со всеми данными и возвращать строку с опытом.
Пример:
showExperience(personalPlanPeter) => '1 month'
P.S. желательно использовать деструктуризацию, но не обязательно */

function showExperience(plan) {
    const { exp } = plan.skills;
    //const NewPersonalPlanPeter = {...personalPlanPeter};
    //console.log(NewPersonalPlanPeter.skills.exp);
    return exp;
}
showExperience(personalPlanPeter);
console.log(showExperience(personalPlanPeter));

/* 2) Напишите функцию showProgrammingLangs, которая будет принимать в себя 
объект со всеми данными и возвращать строку в нужном виде.
Пример:
showProgrammingLangs(personalPlanPeter)  =>
"Язык js изучен на 20% Язык php изучен на 10%"
Причем функция должна работать вне зависимости от количества языков. 
Если ни один не указан, то возвращается пустая строка.
P.S. Для переноса строки используется \n в конце строки. */

function showProgrammingLangs(plan) {
    let str = '';
    const { programmingLangs } = plan.skills;
    for (let key in programmingLangs) {
        str += `Язык ${key} изучен на ${programmingLangs[key]}\n`;
    }
    return str;
}
showProgrammingLangs(personalPlanPeter);
console.log(showProgrammingLangs(personalPlanPeter));




// упражнение по написанию кода 11. Работа с массивами

/*
Задачи:

1) Напишите функцию showFamily, которая будет принимать в 
себя массив строк и возвращать сообщение в нужном формате.
showFamily(family)  => 'Семья состоит из: Peter Ann Alex Linda'
Имена подставляются автоматически из массива. Если массив пустой, 
то выводится сообщение 'Семья пуста'

2) напишите функцию standardizeStrings, которая будет принимать 
в себя массив строк и будет выводить в консоль эти строки 
в нижнем регистре.
Пример:
standardizeStrings(favoriteCities)  выведет в консоль

lisbon
rome
milan
dublin

*/

const familyy = ['Peter', 'Ann', 'Alex', 'Linda'];

function showFamily(arr) {
    if (arr.length === 0) {
        return `Семья пуста`;
    }
    return `Семья состоит из: ${arr.join(' ')}`;
};
console.log(showFamily(familyy));


const family = ['Peter', 'Ann', 'Alex', 'Linda'];

function showFamily(arr) {
    let str = '';
    if (arr.length === 0) {
        str = `Семья пуста`;
    } else { str = `Семья состоит из: ` }
    arr.forEach(function (member) {
        str += `${member} `;
    });
    return str;
}
console.log(showFamily(family));

const favoriteCities = ['liSBon', 'ROME', 'miLan', 'Dublin'];

function standardizeStrings(arr) {
    let str = ''
    arr.forEach(function (city) {
        str += `${city.toLowerCase()} \n`;
        console.log(city.toLowerCase());
    });
    //console.log(city.toLowerCase());
    //return str;
}
standardizeStrings(favoriteCities)
//console.log(standardizeStrings(favoriteCities));



// упражнение по написанию кода 12. Работа с массивами ч2

/*
3) Задача с собеседований. Напишите функцию reverse, 
которая принимает в себя строку и возвращает эту строку 
в обратном порядке.

Пример:

const someString = 'This is some strange string';
reverse(someString) => 'gnirts egnarts emos si sihT'

Функцию можно применить к любой строке. 
Если в функцию приходит не строка - вернуть сообщение "Ошибка!" */

const someString = 'This is some strange string';

function reverse(str) {
    let strin = '';
    if (typeof (str) == 'string') {
        for (let i = str.length - 1; i >= 0; i--) {
            strin += str[i];
        }
    } else { strin = 'Ошибка!' }
    return strin;
}

console.log(reverse(someString));

// решение при помощи методов

const someStrangeString = 'This is some strange string';

function reverse(string) {
    if (typeof (string) !== 'string') {
        return 'Ошибка!';
    }
    return string.split('').reverse().join('');
}

console.log(reverse(someStrangeString));

/*
4) Представьте такую реальную ситуацию. У вас есть банкомат, 
который выдает деньги из двух разных банков в разных валютах. 
Один банк основной с базовыми валютами, второй дополнительный 
с прочими валютами:

const baseCurrencies = ['USD', 'EUR'];
const additionalCurrencies = ['UAH', 'RUB', 'CNY'];
Вам нужно создать главную функцию банкомата availableCurr, 
которая принимает два аргумента: первый - это массив со 
всеми доступными валютами из двух банков сразу (сейчас 
представим, что они не могут повторяться), второй - 
необязательный аргумент, который указывает ту валюту, 
которая сейчас закончилась в банкомате. Если массив в 
первом аргументе пустой - то функция возвращает строку 
'Нет доступных валют'. Функция возвращает строку в 
нужном виде.

Пример:

availableCurr(['UAH', 'RUB', 'CNY'], 'CNY')
Вернет строку:

Доступные валюты:
UAH
RUB
Заметьте:

- CNY (юань) исчез из списка валют, значит 
такая валюта закончилась

- После валюты: стоит перенос строки \n, и 
после каждой валюты тоже. Это важно для тестов

- Данные для первого аргумента должны приходить 
сразу из двух банков, причем сначала baseCurrencies, 
потом additionalCurrencies по порядку
*/

const baseCurrencies = ['USD', 'EUR'];
const additionalCurrencies = ['UAH', 'RUB', 'CNY'];

function availableCurr(arr, missingCurr, net) {
    let str = '';
    //if (arr.length === 0) {
    //    str += 'Нет доступных валют';
    //} else { str += 'Доступные валюты: \n'}
    arr.length === 0 ? str = 'Нет доступных валют' : str = 'Доступные валюты:\n';

    // ПРАВИЛЬНО:  let str = arr.length === 0 ? 'Нет доступных валют' : 'Доступные валюты:\n';


    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === missingCurr) {
            continue;
        }
        str += `${arr[i]}\n`;
    }
    return str;
}
console.log(availableCurr([...baseCurrencies, ...additionalCurrencies], 'CNY'));

// улучшенная версия

const baseCurrenciesss = ['USD', 'EUR'];
const additionalCurrenciesss = ['UAH', 'RUB', 'CNY'];


function availableCurr(atmCurrencies, ...missingCurrencies) {
    var availableCurrencies = atmCurrencies.filter(curr => !missingCurrencies.includes(curr));

    if (availableCurrencies.length === 0)
        return 'Нет доступных валют';

    return 'Доступные валюты:\n' + availableCurrencies.join('\n');
}

console.log(availableCurr(
    [...baseCurrencies, ...additionalCurrencies],
    'EUR', 'UAH', 'RUB', 'CNY'));


// -------------------- lesson 25 (35) --------------------

// основы Объектно-ориентированного программирования, прототипно-ориентированное наследие
// стиль -- прототипно-ориентированное программирование

// подходы в программировании
// истинный
// функциональный
// объектно-ориентированный (JS) -- 
// Главная роль ОБЪЕКТ (содержит методы, свойства, 
// любой тип данных, представляет целостную сущность)
// процедурный

// Смысл ООП -- представить вещь как объект с набором свойств методов

'fgkfdkgd' // -- примитив, обычный тип данных
let str35 = 'some'; // метод, свойство -- объект
let srt35Obj = String(str35);

console.log(typeof (str35)); // string
console.log(typeof (str35Obj)); // object


const soldier = { // Один большой (главный прототип)
    health: 400, // например, модального окна (ширина, высота, функционал)
    armor: 100
};

const john = { // прототип модального окна от главного
    health: 100,
}

// УСТАРЕВШИЙ формат
// __proto__ -- deprecate (устаревшее)
john.__proto__ = soldier; // джон -- прототип солдата
console.log(john); // вывод { health: 100 }
console.log(john.armor); // вывод 100

console.log(john.health);
console.log(soldier.health);
// благодаря прототипам john получил свойство armor

// вместо Proto используем object.create, object.get/(set)PrototypeOf

Object.setPrototypeOf(john, soldier); // 1 -- объект, которому назначается прототип 2 в динамике
// это идентично 'john.__proto__ = soldier;'

// обычно это делается в статике:

const john = Object.create(soldier); // создаем новый объект Джон, который
// будет наследоваться от soldier

// -------------------- lesson 26 (36) --------------------

// практика 4. используем объекты ( practice4.js )

// ------------------------------ Homework #11 (после урока 36) ------------------------------

/*
У вас есть небольшой кусочек данных о торговом центре, 
которые записаны в объекте shoppingMallData. 
Они содержат массив с данными о магазинах, где указана 
длина и ширина помещения; высоту помещения; 
стоимость отопления за 1 кубический метр и бюджет на оплату отопления за месяц.

Основная задача - это написать функцию isBudgetEnough, 
которая будет возвращать строку. 
Если бюджета хватает для отопления всего объема торгового центра - 
выводится 'Бюджета достаточно', если нет - 'Бюджета недостаточно'. И все

Но эта задача содержит несколько подзадач внутри:

- вычисление общей площади всех магазинов,
 которая вычисляется как длина магазина, 
 умноженная на его ширину;

- вычисление общего объема торгового центра, 
так как цена отопления указана в кубических метрах;

- определение того, хватает ли бюджета на оплату такого объема;

- все числа идут без единиц измерения для упрощения, просто цифры и все;

- функция должна продолжать работать, даже если изменяется 
количество магазинов, высота, бюджет или подставляется 
вообще другой объект.
*/

const shoppingMallData = {
    shops: [
        {
            width: 10,
            length: 5
        },
        {
            width: 15,
            length: 7
        },
        {
            width: 20,
            length: 5
        },
        {
            width: 8,
            length: 10
        } // длина и ширина помещений
    ],
    height: 5, // высота помещения
    moneyPer1m3: 30, // стоимость отопления за 1 м3
    budget: 50000 // бюджет на оплату отопления за месяц
}

function isBudgetEnough(data) {
    /* вычисление общей площади всех магазинов,
    - вычисление общего объема торгового центра, 
    так как цена отопления указана в кубических метрах;
    - определение того, хватает ли бюджета на оплату такого объема; */
    let square = 0;
    let volume = 0;

    data.shops.forEach(shop => {
        square += shop.width * shop.length;
    });
    volume = square * data.height;


    if (data.budget - (volume * data.moneyPer1m3) >= 0) {
        return 'Бюджета достаточно'
    } else {
        return 'Бюджета недостаточно'
    }
}

console.log(isBudgetEnough(shoppingMallData));

/*
Задача:

У вас есть список учеников, которые хотят поиграть в игру:

const students = ['Peter', 'Andrew', 'Ann', 'Mark', 'Josh', 'Sandra', 'Cris', 'Bernard', 'Takesi', 'Sam'];
Но команд может быть только 3 по 3 человека. 
Напишите функцию sortStudentsByGroups, 
которая принимает в себя массив строк.

Внутри она сначала сортирует имена по алфавиту. 
Затем распределяет учеников по 3 человека в 3 группы по алфавитному порядку. 
Эти группы должны быть массивами. Как итог, функция возвращает новый массив 
с тремя командами и строкой как 4й элемент.

Пример:

sortStudentsByGroups(students)  =>

[
  [ 'Andrew', 'Ann', 'Bernard' ],
  [ 'Cris', 'Josh', 'Mark' ],
  [ 'Peter', 'Sam', 'Sandra' ],
  'Оставшиеся студенты: Takesi'
]
Если убрать одно студента из списка, то результат будет:

[
  [ 'Andrew', 'Ann', 'Bernard' ],
  [ 'Cris', 'Josh', 'Mark' ],
  [ 'Peter', 'Sam', 'Sandra' ],
  'Оставшиеся студенты: -'
]
А если добавить одного, то:

[
  [ 'Andrew', 'Ann', 'Bernard' ],
  [ 'Cris', 'Josh', 'Mark' ],
  [ 'Peter', 'Sam', 'Sandra' ],
  'Оставшиеся студенты: Takesi, Somebody'
]
То есть, меняется содержимое строки. Все оставшиеся ученики попадают туда.

Задача интересная, немного заковыристая, но все необходимое 
для неё мы уже проходили. Просто распишите логику действий строка за строкой.
*/
const students = ['Peter', 'Andrew', 'Ann', 'Mark', 'Josh', 'Sandra', 'Cris', 'Bernard', 'Takesi', 'Sam'];

function sortStudentsByGroups(arr) {
    // Сортируем массив по алфавиту
    const sorted = arr.slice().sort();

    // Создаем 3 группы по 3 человека
    const groups = [];
    for (let i = 0; i < 3; i++) {
        groups.push(sorted.slice(i * 3, i * 3 + 3));
    }

    // Формируем строку с оставшимися студентами
    const remaining = sorted.slice(9);
    let remainingStr;

    if (remaining.length === 0) {
        remainingStr = 'Оставшиеся студенты: -';
    } else {
        remainingStr = `Оставшиеся студенты: ${remaining.join(', ')}`;
    }

    // Возвращаем результат
    return [...groups, remainingStr];
}


// ультра решение на прод

const student = ['Peter', 'Andrew', 'Ann', 'Mark', 'Josh', 'Sandra', 'Cris', 'Bernard', 'Takesi', 'Sam']; // 'Sam'
const GROUP_SIZE = 3;


function splitIntoChunks(arr, chunkSize) {
    let result = [];
    for (let i = 0; i < arr.length; i += chunkSize) {
        result.push(arr.slice(i, i + chunkSize));
    }
    return result;
}

function sortStudentsByGroups(arr) {
    const sortedStudents = arr.slice().sort();
    const groups = splitIntoChunks(sortedStudents, GROUP_SIZE);

    const createRemainingStudentsStr = (remainingStudents) =>
        'Оставшиеся студенты: ' + (remainingStudents.length > 0 ? remainingStudents.join(', ') : '-');

    if (groups.length === 0) {
        return [createRemainingStudentsStr([])];
    }

    const isFullGroups = groups.at(-1).length === GROUP_SIZE;
    const remainingStudents = isFullGroups ? [] : groups.pop();

    return [...groups, createRemainingStudentsStr(remainingStudents)];
}

console.log(sortStudentsByGroups(student));



// -------------------- lesson 27 (37) --------------------

// Отлавливаем ошибки в своем коде при помощи консоли разработчика. Breakpoints

function hello() {
    console.log('hello world');
}

hello();

function hi() {
    console.log('say hi');
}

hi();

const arr = [1, 14, 4, 30, 54],
    sorted = arr.sort(compareNum);

function compareNum(a, b) {
    return a - b;
}
console.log(sorted);

// Структура консоли:
/*
1) Elements -- html структура, стили css, которые применяются к каждому отдельному тегу; .hov/.cls -- псевдоклассы и псевдоселекторы
2) Console -- 
3) Sources -- исходные доступные материалы
4) Network -- работа с сетью. Как быстро загружаются скрипты, структуры, отслеживание запросов 
5) Performance -- работа и загрузка структуры
6) Memory --
7) Application --
8) Security --
9) Audits --
*/

// Остановимся на вкладке Source. Как дебажить наш код? 
// Breakpoints -- метка, позволяющая останавливать код на определенном участке
// Выбираем необходимую строку, кликая на ее номер.
// можно использовать команду debugger как breakpoint

// -------------------- lesson 28 (38) --------------------

// Динамическая типизация в JS
// Возможность 1 типа данных превращаться в другой тип данных (строка -- число и наоборот, объект -- булкой)
// в других ЯП есть статическая типизация (число останется числом)

// smth to String
// 1)
console.log(typeof (String(null))); // string
console.log(String(null)); // null

// 2) конкатенация (сложение строки с чем-то (в т.ч со строкой))
// ПРИ СЛОЖЕНИИ СО СТРОКОЙ ВСЕ РАВНО ПОЛУЧАЕТСЯ СТРОКА
console.log(typeof (5 + ''));

const num38 = 5;
console.log('http://vk.com/catalog/' + num38); // старый код, есть интерполяция

const fontSize = 26 + 'px';


// smth to Number
// 1)
console.log(typeof (Number('4')));

// 2) унарный плюс
console.log(typeof (+'4'));

// 3)
console.log(typeof (parseInt('15px', 10)));

// реальное применение

let answ = +prompt('Hello', '');


// smth to Boolean
// 1)
// 0, -0 (-0.0; -0x0), 0n (0x0n; but -0n === 0n), '', null, undefined, NaN, false; -- false
// все остальное -- true

let switcher = null;

if (switcher) {
    console.log('working...');
}

// false -- ничего не выводится

switcher = 1;

if (switcher) {
    console.log('working...');
}

// true

// 2)
console.log(typeof (Boolean('4')));

// 3)
console.log(typeof (!!4444));

console.log(Boolean(0)); // выдаст true/false
console.log(0 == []);

let testArray = [];
let testNumber = 0;
console.log(testArray == testNumber);




// ВСЕГДА ЭКВИВАЛЕНТНА  console.log(typeof (4444));
// !! -- принудительное преобразование любого значения в булку, 
// основано на truthy/falsy (истинно-/лже-подобное)

// -------------------- lesson 29 (39) --------------------

// замыкание и лексическое окружение (closure and lexical environment JS)

let number29 = 5;

function logNumber() {
    console.log(number29);
}

number29 = 6;

logNumber();

// let number -- undefined
// присвоение 5
// func declaration -- переменная logNumber существует, равна undefined
// нет аргумента в функе -- надо взять number29
// присвоение 6 вместо 5

let number_29 = 5; debugger

function logNumber() {
    let number_29 = 4; debugger
    console.log(number_29);
}

number_29 = 6;

logNumber(); debugger

/*
Подробная работа кода:
*) Любой скрипт (в т.ч функция) содержит технический объект лексического окружения (локал/глобал)
1) Объявление переменной 'let number_29' -- значение undefined
1.1) Присвоение значения 'let number_29 = 5;' (global)
2) Перескакиваем на строчку 'number_29 = 6;', Переписали значение с 5 на 6.
2.1) Далее вызов функции 'logNumber();' Значение переменной все еще 6.
3) На следующем шаге попадаем в функцию, на строку 'let number_29 = 4;'
3.1) Сначала 'let number_29' -- значение undefined (local, this; global -- 6)
3.2) после -- 'let number_29 = 4;' (this -- undefined, local -- 4; global -- 6)

Внутреннее лексическое окружение (environment record) -- ОБЪЕКТ (технический), в котором как свойства
хранятся все локальные переменные этой функции (также this)

Внешнее лексическое окружение -- (соотв. коду снаружи)
функа получает текущее значение внешних переменных (последнее значение)

КАЖДЫЙ ВЫЗОВ ФУНКИ -- СОЗДАНИЕ НОВОГО ЛЕКСИЧЕСКОГО ОКРУЖЕНИЯ
*/

function createCounter() {
    let counter = 0;

    const myFunction = function () {
        counter += 1;
        return counter;
    }
    return myFunction;
}

const increment = createCounter();

const c1 = increment();
const c2 = increment();
const c3 = increment();

console.log(c1, c2, c3);

// Каким образом функция знает, что помещать в лексическое окружение?
// Ответ: реализация происходит через скрытое свойство environment, которое
// ссылается на лексическое окружение места, где эта функция была создана

// т. е была создана функция myFunction, которая получила ссылку на лексическое окружение
// того места, где она была создана, то есть в лексическом окружении функции createCounter

// Замыкание это функция, которая запоминает свои внешние переменные и может получить к ним доступ

// пример из статьи про замыкания

let val = 7
function createAdder() {
    function addNumbers(a, b) {
        let ret = a + b
        return ret
    }
    return addNumbers
}
let adder = createAdder()
let sum = adder(val, 8)
console.log('example of function returning a function: ', sum)

// когда функция объявляется, то она содержит описание функции и замыкание. 
// Замыкание — это коллекция всех переменных из области видимости во время создания функции.

// Вы можете спросить, а все ли функции содержат замыкания? 
// Даже те, которые создаются в глобальной области видимости? 
// Ответ будет положительным.

// Когда функция возвращает функцию, тогда концепция замыканий становится более актуальной. 
// Возвращаемая функция имеет доступ к переменным, которые не находятся в глобальной 
// области видимости, но при этом существуют в её же замыкании.

// conclusion

/* Способ, с помощью которого я навсегда запомнил замыкания — это сравнение их с рюкзаком. 
Когда функция создана и передаётся куда-либо, или возвращается из другой функции, 
то она носит с собой рюкзак. А в этом рюкзаке хранятся все переменные, которые были в 
области видимости во время создания этой функции. */

// -------------------- homework TEST --------------------
function test() {
    function foo(a, b) {
        const [first] = a;
        const { eng } = b;

        return `${first} ${eng}`;
    }

    const result = foo(['Привет', 'Hello'], { ru: 'Мир', eng: 'World' })
    console.log(result)
}
//c onst [first] = a аналогично const first = a[0]
// const {eng} = b аналогично const eng = b.eng

// -------------------- lesson 30 (40) --------------------


// 1) Какое будет выведено значение:
let X = 5; alert(X++);
// ОТВЕТ: 5, потому что постфиксная форма записи инкремента. сначала возврат исходного выражения, потом +1

// 2) Чему равно такое выражение:
[] + false - null + true
// ОТВЕТ: [] == '', пустая строка + false = 'false', 'false' - (- пытается превратить операнды в числа)
// - null  = NaN, NaN + true = NaN

// 3) Что выведет этот код:
let y = 1; let x = y = 2; alert(x);
// ОТВЕТ:

// 4) Чему равна сумма
[] + 1 + 2
// ОТВЕТ: '' + 1 = '1', '1' + 2 = '12'

// 5) Что выведет этот код: 
alert("1"[0])
// ОТВЕТ: 1, выводит элемент по порядку, т.е console.log('123'[1]) - выведет 2

// 6) Чему равно 
console.log(2 && 1 && null && 0 && undefined)
// ОТВЕТ: null, && Запинается на ЛЖИ

// 7) Есть ли разница между выражениями:
console.log(!!(1 && 2))

console.log((1 && 2))
// ОТВЕТ: да, !! превращает выражение в булку

// 8) Что выведет этот код:
alert(null || 2 && 3 || 4);
// ОТВЕТ: 3

// 9) Правда ли что а == b 
a = [1, 2, 3]; b = [1, 2, 3];
// ОТВЕТ:

// 10) Что выведет этот код:
alert(+"Infinity");
// ОТВЕТ: + превращает строку в число, вывод --- Infinity (тип данных число)

// 11) Что выведет этот код:
console.log('Ёжик' > 'яблоко')
// ОТВЕТ: открываем кодировку unicode
// 'Ё' → U+0401 (код: 1025)
// 'я' → U+044F (код: 1103)
// 1025 < 1103 --- FALSE

// пример с латиницей:
console.log('Apple' > 'apple');  // false (A=65, a=97)

// 12) Чему равно выражение:
console.log(0 || '' || 2 || undefined || true || false);
// ОТВЕТ: ИЛИ запинается на ПРАВДЕ ---- ответ 2.

// -------------------- lesson 31 (41) --------------------

// Получение элементов со страницы

let box = document.getElementById('box');

console.log(box); // получить элемент по ID

// можно получать элементы по тегу (button, div), но их может быть много

const btns = document.getElementsByTagName('button')[1]; // конкретная кнопка -- вторая
console.log(btns); // второй вариант console.log(btns[1])
// если переменная одна -- все равно будет HTMLCollection [button]

const circles = document.getElementsByClassName('circle'); // получи элементы через Класс
console.log(circles);

// современные методы

const hearts = document.querySelectorAll('.heart');
hearts.forEach(item => {
    console.log(item);
});

const oneHeart = document.querySelector('.heart'); // первый элемент при помощи CSS селектора
console.log(oneHeart);

// -------------------- lesson 32 (42) --------------------

// Действия с элементами на странице

// измненение стилей элементов
// файл actionsWithElements.js

// -------------------- lesson 33 (43) --------------------

// практика. архив 'project_mDB'

// -------------------- lesson 34 (44) --------------------

// События и их обработчики

/*
События -- инструмент взаимодействия с элементами на странице

События -- сигнал от браузера (клик, даблклик, наведение/отведение мыши, прокрутка колесиком, отправка данных по форме, нажатие клавиш) 
что что-то произошло

Чтобы использовать любое событие, необходимо назначить обработчик событий.
Это функция, которая срабатывает, когда событие произошло (клик мышки и тд)

3 способа: 

1) HTML-атрибут (on+событие) (ОЧЕНЬ РЕДКО ПРИМЕНЯЕТСЯ)
<button onclick="alert"('click') id='btn'>Нажми меня </button>

2) свойство DOM дерева для событий
*/
const btnss = document.querySelector('button'),
    overlay = document.querySelector('.overlay');
// способы назначения (комментарий ниже. КРАТКО -- НЕ ОЧЕНЬ)
btn.onclick = function () {
    alert('Click');
}

/* ТОЖЕ НЕ ОЧЕНЬ, ПРОБЛЕМА -- если код большой, дважды назначил один и тот же обработчик событий -- покажется ТОЛЬКО второй

3) !!!!!!!!!!!!!!!!! адекватный вариант -- addEventListener/removeEventListener !!!!!!!!!!!!!!!!!
ПЛЮСЫ:
- Позволяет добавлять более одного обработчика для события. 
Это очень полезно для использования в библиотеках, модулях JavaScript и тех случаях, 
когда требуется работать с другими библиотеками или расширениями.

- В отличие от использования свойств вида onXYZ, позволяет он даёт более точный 
контроль над фазой активации слушателя (захват или всплытие).

- Работает на всех целях событий, а не только на элементах HTML и SVG.

СОБЫТИЯ ВЫПОЛНЯЮТСЯ В ПОРЯДКЕ ОЧЕРЕДИ
*/

btn.addEventListener('click', (e) => {
    console.log(e.target); // доступ к элементу (поменять/удалить/изменить цвет)
    e.target.remove(); // удалить
    alert('click');
});

btn.addEventListener('mouseenter', (event) => {
    console.log(e); // из чего состоит объект события (координаты, отступы, сочетания, тип события, target(где произошло событие))
    alert('second click');
});

/*
что за событие произошло? у нас есть объект event -- событие со своими свойствами.
объект события event передается как аргумент в callback-функцию.
ОН ВСЕГДА ИДЕТ ПЕРВЫМ, затем идут аргументы других данных (текстовых и тд)
первый всегда объект события
*/

// удаление обработчиков событий

// Нужно использовать такую же функцию, которую мы назначали!!! (вынести функцию в отдельную переменную)
// А НЕ ДВА РАЗА ПИСАТЬ ОДНУ И ТУ ЖЕ ФУНКЦИЮ, ЭТО БУДУТ РАЗНЫЕ ФУНКЦИИ

const deleteElementTest = (e) => { // поместим функцию в переменную
    console.log(e.target);
};

btn.addEventListener('click', deleteElementTest); // тут не вызываем функцию, мы ссылаемся на нее, что она выполнится после клика
btn.removeEventListener('click', deleteElementTest);

let iIi = 0;
const deleteElement = (e) => {
    e.target.remove();
    iIi++;
    if (iIi == 2) {
        btn.removeEventListener('click', deleteElement);
    }
};


// Всплыние событий (НЕ ПЕРЕМЕННЫХ HOISTING)
// сначала вложенный элемент, потом поднимается по иерархии DOM-дерева на родителе. НО
// каждый раз когда в консоль выводится e.target, мы ссылаемся на элемент, на котором произошло изначальное событие.

const deleteElementt = (e) => {
    console.log(e.target);
    console.log(e.type);
};
btn.addEventListener('click', deleteElementt);
overlay.addEventListener('click', deleteElementt);

// Поправим это через e.currentTarget -- также сначала вложенный элемент btn, затем родитель overlay

// есть метод отменять всплытие событий

// ВСПЛЫТИЕ СОБЫТИЙ -- обработчик событий срабатывает на самом вложенном элементе, затем на родителе (если он есть) и выше по иерархии
// сейчас самое важное -- отменять стандартное поведение в браузере (выделение текста, переход по ссылке, отправка формы)
// 1 способ: вернуть в обработчике события return false
// 2 способ: использовать метод у объекта события

const link = document.querySelector('a');
link.addEventListener('click', (event) => {
    event.preventDefault(); // отменить стандартное поведение в самом начале обработчика событий
    console.log(event.target); // Добавить новое поведение
})


// взять и один и тот же функционал (функцию) повесить на 3+ элемента. как это сделать?
// НЕ ИСПОЛЬЗОВАТЬ querySelectorAll, потому что в псевдомассиве нет таких методов как addEventListener
// ВМЕСТО ЭТОГО ИСПОЛЬЗУЕМ ПЕРЕБОР ПСЕВДОМАССИВА И ВЕШАЕМ ОБРАБОТЧИКИ НА КАЖДЫЙ ЭЛЕМЕНТ

btnss.forEach(btn => {
    btn.addEventListener('click', deleteElement, { once: true });
});

// Опции события. Это третий аргумент -- объект у addEventListener, в который мы можем передавать различные опции.
// Например, capture, once (вместо removeEventListener), passive

// -------------------- lesson 35 (45) --------------------

// Навигация по DOM - элементам, data-атрибуты, преимущество for/of

// взять определенный элемент и обратиться к родителю/следующему элементу и у него поменять класс

// главные элементы DOM-дереве

console.log(document.body); // обращение к body, (можно и к head)
console.log(document.documentElement); // обращение к <html></html>

// получить вложенные элементы от родителя:
// 1
console.log(document.body.childNodes); // псевдомассив [text, div.wrapper, text, script] НА ТЕСТОВОМ ФАЙЛЕ domLearn.html
// childNodes -- позволяет получить все ноды/узлы внутри родителя. Можно получить first/last child отдельно
console.log(document.body.firstChild);
console.log(document.body.lastChild);
/*
всего элементов в псевдомассиве 8: text, div.wrapper, text, script, text, comment, text, script, text
__proto__: NodeList
0: text -- текстовая нода, расположенная между родительской оболочкой и элементов wrapper (перенос строки)
1: div.wrapper
2: перенос строки
3: скрипт (подключение скрипта к странице)
4-8 -- динамические (liveServer) (4: перенос строки, 5: комментарий, 6: перенос строки, 7: скрипт, 8: перенос строки)
*/
// Разница между DOM-элементами и узлами
// Каждая сущность, которая находится на странице -- узел, НО не каждый узел -- элемент. ВСЁ, что в тегах -- элементы
// ВСЁ, что не видим (переносы строк, текстовые элементы) -- узлы
// ex: <li>1</li> -- ListItem -- DOM-element, '1' -- DOM-knot

// 2
// Получение родителя, соседей, детей
console.log(document.querySelector('#current').parentNode); // Получение родителя
console.log(document.querySelector('#current').parentNode.parentNode); // Получение родителя родителя

// 3 

// data-атрибуты. НЕ хватает id, class, мало ориентиров. Сделали data-атрибуты: 'data-...' (current, modal. close, etc)="true"
console.log(document.querySelector('[data-current="3"]').nextSibling); // получить следующий элемент (сосед)
console.log(document.querySelector('[data-current="3"]').previousSibling); // получить предыдущий элемент (сосед)

// Все эти методы ориентируются на ноды (узлы). Чтобы этого не случалось, есть аналоги: nextElementSibling, 
// previousElementSibling, parentElement (получение ЭЛЕМЕНТА), firstElementChild, lastElementChild

// с childNodes можно создать аналог вручную (псевдоколлекция)

for (let node of document.body.childNodes) {
    if (node.nodeName == '#text') {
        continue;
    }

    console.log(node);
}

// -------------------- lesson 36 (46) --------------------

// Рекурсия -- метод, когда функция вызывает саму себя 

// возведение в степень

pow(2, 2) // 4
pow(2, 3) // 8

function pow(x, n) {
    let result = 1;

    for (let i = 0; i < n; i++) {
        result *= x;
    }
    return result;
}


function pow(x, n) {
    if (n === 1) {
        return x;
    } else {
        return x * pow(x, n - 1);
    }
}

// База рекурсии -- завершение рекурсии (n = 1, например)
// Шаг рекурсии -- запуск вложенной функции с другим значением (шаг = 1)
// Глубина рекурсии -- общее количество вложенных вызовов функции (n)
// Максимальная глубина рекурсии -- max "ныряние" рекурсии самой в себя. ~10000

// Итеративный подход обычно эффективнее. Рекурсия делает функции проще, но имеет ограничение по глубине.

let studentsTest = {
    js: [{
        name: 'John',
        progress: 100
    }, {
        name: 'Ivan',
        progress: 60
    }],

    html: {
        basic: [{
            name: 'Peter',
            progress: 20
        }, {
            name: 'Ann',
            progress: 18
        }],

        pro: [{
            name: 'Sam',
            progress: 10
        }],
        some: {
            etc: [{
                name: 'Jonathan',
                progress: 52
            }, {
                name: 'Nick',
                progress: 99
            }]
        }
    }
};

// посчитать средний прогресс всех студентов

function getTotalProgressByIteration(data) {
    let total = 0;
    let studentsTest = 0;

    for (let course of Object.values(data)) {
        if (Array.isArray(course)) {
            studentsTest += course.length;

            for (let i = 0; i < course.length; i++) {
                total += course[i].progress;
            }
        } else {
            for (let subCourse of Object.values(course)) {
                studentsTest += subCourse.length;

                for (let i = 0; i < subCourse.length; i++) {
                    total += subCourse[i].progress;
                }
            }
        }
    }

    return total / studentsTest;
}

console.log(getTotalProgressByIteration(studentsTest));

// если появится еще один подкурс внутри html, в котором будет объект со свойствами и еще одним массивом, код не сработает

// рекурсия сработает)

function getTotalProgressByRecursion(data) {
    if (Array.isArray(data)) {
        let total = 0;

        for (let i = 0; i < data.length; i++) {
            total += data[i].progress;
        }

        return [total, data.length];
    } else {
        let total = [0, 0];

        for (let subData of Object.values(data)) {
            const subDataArr = getTotalProgressByRecursion(subData);
            total[0] += subDataArr[0];
            total[1] += subDataArr[1];
        }
        return total;
    }
}

const resultRec = getTotalProgressByRecursion(studentsTest);
console.log(resultRec[0] / resultRec[1]);

// -------------------- lesson 37 (47.1) --------------------

// ------------------------------ Homework #12 (после урока 46) ------------------------------

/* Напишите функцию, которая вычисляет факториал.

Задание простое, но нужно понимать что такое факториал вообще. 
Факториал  – это число, умноженное на "себя минус один", 
затем на "себя минус два", и так далее до 1. Факториал n обозначается как n!

Отсюда мы можем понять, что функция должна принимать 1 аргумент, 
который будет являться числом. Будет неплохо, если вы на 
собеседовании сразу напишите проверку на приходящее значение :) 
Поэтому, если в нашу функцию приходит дробное число или не число - возвращается строка 
с любым сообщением на ваше усмотрение. Если 0 и меньше - возвращается число 1.

Сам же факториал с примерами выглядит вот так:

n! = n * (n - 1) * (n - 2) * ... * 1 - это общая формула

Примеры значений для разных n:

1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120
То есть, вызов нашей функции factorial(5) возвращает число 120

factorial(4) => 24

Решить задачу нужно через рекурсию.

*/

function factorial(n) {
    if (n < 0 || typeof (n) !== 'number' || !Number.isInteger(n)) {
        return "Введите целый и неотрицательный тип данных 'число'";
    }
    let result = 1;
    for (let i = 1; i <= n; i++) {
        result *= i
    }
    return result;
}
console.log(factorial(-1));
console.log(factorial("mama"));
console.log(factorial(0));
console.log(factorial(1));
console.log(factorial(2));
console.log(factorial(3));
console.log(factorial(4));
console.log(factorial(5));

function factorial(n) {
    if (n < 0 || typeof (n) !== 'number' || !Number.isInteger(n)) {
        return "Введите целый и неотрицательный тип данных 'число'";
    }
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}
console.log(factorial(-10));
// -------------------- lesson 38 (47) --------------------

// Практика

/*
1) Реализовать функционал, что после заполнения формы и нажатия кнопки "подтвердить" - новый фильм добавляется
в список. Страница не должна перезагружаться. Новый фильм должен добавляться в movieDB.movies. Для получения
доступа к значению input - обращаемся к нему как input.value.

2) если название фильма больше, чем 21 символ - обрезать его и добавить три точки

3) при клике на мусорную корзину - элемент будет удаляться из списка

4) если в форме стоит галочка "сделать любимым" - в консоль вывести сообщение: "добавляем любимый фильм"

5) фильмы должны быть отсортированы по алфавиту.
*/

// -------------------- lesson 39 (48) --------------------

// события на мобильных устройствах

// в мобилках нет событий мыши (клики, наведения). есть тапы (1 и несколько)

// 6 типов событий в мобильном браузере

// touchstart (коснулся и событие выполнилось)
// touchmove (касание с движением)
// touchend (прекращение касания) 
// 3 дополнительных
// touchenter (ведение пальцем по экрану, наводя на элемент)
// touchleave (обратное enter. когда палец продолжил скользить за пределы элемента)
// touchcancel (точка соприкосновения больше не регистрируется)

window.addEventListener('DOMContentLoaded', () => {
    const box = document.querySelector('.box');

    box.addEventListener('touchstart', (e) => {
        e.preventDefault();
        console.log('start');
        console.log(e.touches);
    });

    box.addEventListener('touchmove', (e) => {
        e.preventDefault();
        console.log('move');
    });

    box.addEventListener('touchend', (e) => {
        e.preventDefault();
        console.log('end');
    });
});

// Большие сложные события -- scope (Зум)/pitch (щепотка), swipe, drag'n'drop (удерживай и бросай (перетаскивание))

// Дополнительные свойства объекта у события (у event)
// 3 Главных свойства при работе с мобилками
// 1 -- touches (список пальцев, которые сейчас взаимодействуют с экраном (касаются экрана))
// 2 -- targetTouches (все пальцы взаимодействуют с объектом)
// 3 -- changedTouches (список пальцев, участвующих в текущем событии (touchend -- палец был убран - записан, даже если остальные остались на экране))

// вариант реализации более сложных событий:
/* 
box.addEventListener('touchend', (e) => {
        e.preventDefault();
        console.log(e.targetTouches[0].pageX); // смена координат до определенной величины -- свайп в слайдере
    });
*/

// сложные события в основном не создаются с нуля. есть готовые инструменты по типу Hammer.js

// -------------------- lesson 40 (49) --------------------

// загрузка скриптов на страницу (оптимизация). Атрибуты Async, defer, динамические скрипты

// Как загружается страница? когда *.html попадает в браузер, он идентифицирует ее как html и начинает загрузку
// подгружает мета-теги (head), title, стили (шрифты, ccs), далее -- body (верстка тег за тегом), затем -- скрипты
// Проблема -- помещение скрипта в head. 1) страница еще не построилась полностью, 
// и если в скрипте будет взаимодействие с элементами на странице -- будет ошибка (можно решить через DOMContentLoaded)
// 2) при загрузке скрипт блокирует страницу (после полной загрузки скрипта вся DOM структура (body) не загрузится)

// Defer, Async -- решение проблемы

// <script defer src="js/script.js"></script> // html-структура из файла testTaskLesson49.html

const p = document.querySelectorAll('p');
console.log(p);

// Если использовать defer -- все отрабатывает. Без него -- NodeList пустой (скрипт запустился до формирования параграфов).

// Что дает defer? Атрибут сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме
// затем запустить скрипт, когда он загрузится
// 1) Скрипты с defer не блокируют страницу! после скрипта DOM-структура формируется.
// Но скрипт выполнится тогда, когда он загрузится? А вдруг структура продолжит формироваться?
// 2) Скрипты с defer ВСЕГДА выполняются, когда DOM-дерево уже готово (срабатывают до события DOMContentLoaded)
// Теперь с атрибутом defer такой скрипт можно поместить в head
// Скрипты с defer сохраняют порядок относительно друг друга как и обычные скрипты 
// (есть недостаток -- маленький скрипт второй будет ждать выполнения первого -- большого.)

// Для чего нужно использовать defer?
// 1) соблюдение порядка выполнения скриптов (когда уверены, что страница сформирована) --
// подключаем библиотеку с полезными утилитами -- jQuery, а следущим -- скрипт, использующий возможности данной библиотеки и зависит от нее.
// При этом, страница не блокируется, пока скрипты загружаются параллельно ей.
// 2) Скрипты можно поместить в head (но google test speed и др. будет "ругаться" на такую конструкцию)


// Async


// 1) Страница НЕ ждет асинхронных скриптов (содержимое обрабатывается и отображается)
// 2) Событие DOMContentLoaded и асинхронные скрипты не ждут друг друга (запуск сразу после загрузки)
// 3) Обычные скрипты и скрипты с Async не ждут друг друга (абсолютно независимые)

// Затем такое поведение нам необходимо?
// 1) При загрузке сторонних скриптов (метрики, счетчики), которые не связаны с DOM-структурой. Скрипт НЕ должен зависеть от других скриптов

// Мы можем создавать новые элементы на странице. Почему не создать тег скрипт и не поместить его на страницу?

function loadScript(src) {
    const script = document.createElement('script');
    script.src = src;
    script.async = false; // отключение асинхронности, скрипт будет вести себя как обычный скрипт, который помещен на страницу
    // Будут выполняться строго друг за другом
    document.body.append(script); // поместить в конец боди
}
loadScript('js/test.js'); // console.log('test');
loadScript('js/some.js'); // console.log('some');
// этот скрипт будет выполняться после того, как будет добавлен в документ (после выполнения document.body.append(script);)
// Динамические скрипты по умолчанию ведут себя как Async.

// Такой способ используется довольно часто, например youtube iframe API (создаем скрипт, помещаем src, помещаем скрипт на страницу)

// -------------------- lesson 41 (test) --------------------





// -------------------- lesson 42 (52) --------------------

// Оператор нулевого слияния (Nullish, ??) ES11

const newBox = document.querySelector('.box');

const newHeight = 100;
const newWidth = 400;

function changeParams(elem, h, w) {
    elem.style.height = `${h ?? 200}px`; // 200 -- стандартное значение, если h не задана
    elem.style.width = `${w ?? 200}px`;
    elem.innerHTML = h ?? 200 * w ?? 200; // получим 100. первое правдивое значение
}
changeParams(box, newHeight, newWidth); // нужно убрать newHeight, newWidth, иначе ошибка

// в переменные могут приходить ложные значения, например 0 (false в булке)
// иначе можно использовать оператор нулевого слияния. он реагирует не на все falsy-значения (0, null, undefined, NaN, """), а только на null/undefined

let newUserName;
let newUserKey;
console.log(newUserName ?? newUserKey ?? 'User'); // похож на оператор ИЛИ, только обращает 
// внимание на исходные данные (null/undefined)
// если в 1 выражении получено null/undefined -- выведется второе значение 'user'

// из операторов можно выстраивать цепочку для получения первого существующего значения (пример выше)

// логические операторы И и Нуллиш нельзя использовать вместе (при замене ИЛИ на Нуллиш не пропустили такую комбинацию)

// -------------------- lesson 43 (53) --------------------

// Optional Chaining Operator --  Оператор опциональной цепочки/последовательности (?.) ES11

/*
Оператор опциональной последовательности (?.) в JavaScript позволяет получить значение свойства, 
находящегося на любом уровне вложенности в цепочке связанных между собой объектов, 
без необходимости проверять каждое из промежуточных свойств на существование. 

Оператор не выбрасывает исключение, если объект, к свойству или методу которого идёт обращение, 
равен null или undefined, — в этих случаях он возвращает undefined. Это упрощает доступ к 
значениям в цепочке объектов, когда есть вероятность, что какое-то из них отсутствует.
*/

// Пример. Доступ к двум элементам на странице и один из них выводит в консоль. В HTML существует только один div class="box"
// Подойдет использование testTaskLesson49.html
function lesson43() {

    const box = document.querySelector('.box');
    const block = document.querySelector('.block');

    console.log(block);
}
// при выводе в консоль получим null, так как такой элемент не был найден на странице.
// В работе мы будем обращаться к куче элементов, которых, в теории, может и не быть на странице.

console.log(block.textContent);
console.log(1 + 2);
// После этого мы получим null и ошибку вместо '3'. Для того, чтобы избежать такой ошибки, используют условия
if (block) { // если внутри переменной block что-то существует
    console.log(block.textContent); // выводим текстовый контент переменной
};

// Здесь может помочь Оператор Опциональной Цепочки. Он проверяет выражение слева от себя и останавливает операции, 
// если оно имеет значение undefined или null, возвращая undefined:

console.log(block?.textContent); // undefined 
// это работает на ЧТЕНИЕ свойства. Если попробовать записать туда что-то, будет ошибка:
block?.textContent = '123'; // Invalid left-hard side in assignment, т.к в undefined нельзя записать строку

// Максимальная польза от Оператора Опциональной Цепочки -- когда мы работаем с данными (от пользователя, от веб-сервера), которые
// содержат немного не то, что мы предполагаем:

const userData = {
    name: "Ivan",
    age: null,
    say: function () {
        console.log('say');
    }
};

console.log(userData.skills.js); // получим ошибку, так как поле skills не существует

if (userData && userData.skills && userData.skills.js) { // не выдаст ошибки
    console.log(userData.skills.js);
}

// Аналогично, но проще, без сложных и длинных выражений, избавляемся от лишнего кода:
console.log(userData?.skills?.js); // undefined
// Однако, userData как переменная ДОЛЖНА существовать для проверки, 
// если ее не существует -- будет ошибка -- userData is not defined

// не стоит злоупотреблять данным оператором, однако он работает не только в конструкциях
// со свойствами, но и с круглыми или квадратными скобками:
userData.hey?.(); // Существует ли метод hey? нет -- undefined, Да -- hey


// -------------------- lesson 44 (54) --------------------

// Живые коллекции и полезные методы

// Как мы уже разбирали, DOM-элементы можно получать разными способами и методами.
// Самое популярное -- querySelector(All), остальное -- устаревшее (getElementsBy...)
// Для примера взята стандартная HTML-структура с тремя дивами
// <div class="box"></div>
// <div class="box"></div>
// <div class="box"></div>

// Чтобы получить данные элементы, можно воспользоваться querySelector
const boxesQuery = document.querySelectorAll('.box');
const boxesGet = document.getElementsByClassName('box');

// Получаем разные виды псевдомассивов:
console.log(boxesQuery); // Nodelist
// Получаем определенные методы, которые можем использовать: entries, forEach, item, keys, values
console.log(boxesGet); // HTMLCollection
// Ничего нет, разная структуризация псевдомассивов
// В обоих случаях мы не найдем обычных методов массивов (push, pop, etc...)

// Получить псевдомассив без методов можно также получить следующим образом%
console.log(document.body.children); // HTMLCollection -> script 

// Анализируя данные HTMLCollection, можно увидеть, что они ведут себя немного по-разному.
// Такое явление называется "живые" и "статические" коллекции.

boxesQuery[0].remove();
boxesGet[0].remove();

console.log(boxesQuery); // Псевдомассив с тремя элементами
console.log(boxesGet); // Псевдомассив с одним элементом

// команда .remove() работает с DOM-элементами и удаляет переменные из верстки
// То есть мы должны были получить псевдомассивы с одним и одним элементом соответственно
// Однако в boxesQuery мы получаем 3 элемента -- состояние элемента на момент вызова команды querySelectorAll
// 'отпечаток', что происходило тогда. Данная коллекция СТАТИЧНАЯ, не знает, что было после.
// getElementsByClassName -- ЖИВАЯ, отслеживает все изменения в DOM-дереве и выдает текущий результат
// Аналогично при использовании других getElementsBy.. TagName, Name (которые получают псевдомассивы)

// Использование. Для всех задач подходит querySelectorAll -- статические коллекции. Но иногда можно использовать живые коллекции.
// ОДНАКО у них нет методов для манипуляции. Решение проблемы -- создание массива из массивоподобного объекта

console.log(Array.from(boxesGet)); // обращение к Массиву, создаем массив из массивоподобного объекта boxesGet
// Это самый обычный массив, который содержит все методы массивов. Только теперь он статичный.
// Подходит для отслеживания изменений с элементами в каком-то промежутке времени.
// ex: Получили слепок ДОМ-дерева, в нем будут произведены действия, которые необходимо отследить и получить измененное ДОМ-дерево в текущем состоянии

for (let i = 0; i < 5; i++) {
    const div = document.createElement('div');
    div.classList.add('box');
    document.body.append(div);
    // boxesGet[boxesGet.length] = div; // взять и поместить на последнюю позицию новый элемент -- НЕЛЬЗЯ НАПРЯМУЮ РАБОТАТЬ С HTML-КОЛЛЕКЦИЕЙ!
    // их можно отслеживать (текущие изменения), но в них нет методов для работы! только переводить в обычный массив (статический)
}

// matches -- используется на элементе (найти тот, который подходит по определенным параметрам -- по CSS-селектору)
// т.е среди наших трех дивчиков допишем class="box this"
// как можно найти элемент, который среди прочих содержит другой CSS-селектор?

boxesQuery.forEach(box => {
    // для определения класса можно было использовать box.classList.contains()
    // для определения ИМЕННО СЕЛЕКТОРА (тег, атрибут), то используем matches
    if (box.matches('.this'))
        console.log('this one'); // можно изменить вертску, вывести тот интересующий нас бокс и тд
});

// closest (дилегирование событий)

/*
запишем в HTML обертку на наши дивчики
<div class="wrapper">
    <div class="box"></div>
    <div class="box this"></div>
    <div class="box"></div>
</div>

Теперь можно получить эту обертку изнутри:
*/

console.log(boxesQuery[0].closest('.wrapper')) // первый элемент с таким селектором который будет у тебя родителем

// -------------------- lesson 45 (55) --------------------

// тип данных Symbol
// Symbol -- уникальные идентификаторы. Применять к свойствам объектов

const obj = {
    'name': 'test',
    [Symbol('id')]: 1
}

let id = Symbol('id');
obj[id] = 1;

console.log(obj['id']); // undefined -- обращение к свойству объекта через строку, а использовали Symbol
console.log(obj[id]); // nice
console.log(obj); // вывести весь объект: Symbol(id): 1

// НЕЛЬЗЯ ПИСАТЬ let id = new Symbol('id'); -- ERROR
// Символы всегда уникальны, даже если у них одинаковое описание:
let testID1 = Symbol('id');
let testID2 = Symbol('id');
console.log(testID1 == testID2); // false. одинаковое описание, но сущности одинаковые
console.log(testID1 === testID2); // false

// если захотим обратиться к символу в объекте obj выше, то
console.log(obg['id']); // undefined -- скрытые при обычном доступе свойства, не показываются при переборе объекта
// Свойство существует, но обратиться извне к нему нельзя (нет ссылки на этот Symbol)

// проверим метод перебора  for in

for (let value in obj) console.log(value) // name (symbol нет, приватное (скрытое) свойство)

// Создадим свойство до объекта

let testID = Symbol('id');
const testObject = {
    'name': 'test',
    [id]: 1,
    getId: function () {
        return this[id];
    }
}
console.log(testObject.getId()); // метод по возвращению наружу Symbol
// есть еще встроенный метод
console.log(Object.getOwnPropertySymbols(testObject)); // [Symbol(id)] без значения, но есть ссылка
console.log(testObject[Object.getOwnPropertySymbols(testObject)[0]]); // первое значение Symbol, т.е '1'
// Это бывает полезным, когда символы создаются внутри объекта:

const testObj = {
    'name': 'test',
    [Symbol('id')]: 1,
    getId: function () {
        return this[id];
    }
}
console.log(testObj[Object.getOwnPropertySymbols(testObj)[0]]); // Получим ЗНАЧЕНИЕ, хотя ССЫЛКИ на Символ не было!

// Зачем же все это нужно? Уникальность Символов, их скрытность (приватность)???

// Позволяет быть уверенным в том, что это свойство НЕ будет случайно перезаписано! Наглядно:

const myAwesomeDB = {
    movies: [],
    actors: [],
    id: 123
}

// ...Сторонний код библиотек...

myAwesomeDB.id = '323'; // Перезапись id

console.log(myAwesomeDB['id']);

// Избежать этого -- использовать Символ! [Symbol('id')]: 123
// Если вывести console.log(myAwesomeDB["id"]); то мы получим '323' (обращение по строке)
// А если вывести console.log(myAwesomeDB); то мы получим полный объект с модифицированным свойством и уникальным Symbol

// Если Символ и нужно как-то поменять/взаимодействовать, то console.log(testObj[Object.getOwnPropertySymbols(testObj)[0]]);

// Есть встроенные Символы по типу Symbol.iterator, .match, .replace (6.1.5 The Symbol Type -> 6.1.5.1 Well-Known Symbols)

// При таком синтаксисе мы каждый раз будем создавать свой уникальный Символ с одинаковыми описаниями.
// Однако, иногда необходимо, чтобы Символы с одинаковыми описаниями и именами были одной сущностью 
// (одно описание символа строго соотвествовало одному конкретному Символу) --> насильно лишить их уникальности.
// Это можно сделать при помощи Глобального Реестра Символов.

// Глобальный реестр символов -- 

const testDB = {
    [Symbol.for('id')]: 123456 // Теперь это описание не уникально
}

console.log(testDB[Symbol.for('id')]); // 123456

// Есть обратный метод, который принимает Символ и возвращает его описание -- Symbol.keyFor()
// про Глобальный реестр символов у метода Symbol.for(key) -- ищет существующие символы по заданному ключу 
// и возвращает его, если он найден. В противном случае создается новый символ для данного ключа в глобальном реестре символов.

// -------------------- lesson 46 (56) --------------------

// Дескрипторы свойств и полезные методы объектов
// Тему довольно активно спрашивают на собеседованиях, но не часто используется на работе у новичков

// Каким образом идет определение того, будет ли свойство объект показываться в циклах или нет?
// Дело в том, что у каждого из свойств объекта (помимо значения) есть атрибуты (flags), которые еще глубже определяют работу свойства
// Их всего 3. ОНИ ПРИМЕНЯЮТСЯ ТОЛЬКО К КАКОМУ-ТО ОПРЕДЕЛЕННОМУ СВОЙСТВУ!

// 1) writable -- true (свойство в объекте можно изменить); false -- только для чтения
// 2) enumerable -- true (свойство будет перечисляться в циклах); false -- циклы его игнорируют
// 3) configurable -- true (свойство можно будет удалить, а атрибуты изменить); false -- иначе нельзя

// В обычной работе их не увидеть в консоли, они скрыты. и для создаваемых нами вручную свойств они всегда стоят в 'true'

const testUser = {
    name: 'Alex',
    surname: 'Smith',
    birthday: '20/04/1993',
    showMyPublicData: function () {
        console.log(`${this.name} ${this.surname}`);
    }
}

console.log(Object.getOwnPropertyDescriptor(testUser, 'name')); // Object -> 
// configurable: true, enumerate: true, value: 'Alex', writable: true

// Изменение этих параметров при помощи defineProperty

Object.defineProperty(testUser, 'name', { writeble: false }); // можно создавать и новые свойства с заданными 
// параметрами, которое не было в списке объекта. Если не задавать флаги, они по умолчанию будут FALSE (а не true как три стандартных)

testUser.name = 'test'; // error, READ ONLY

Object.defineProperty(testUser, 'gender', { value: 'male' }); // Создание нового свойства с заданным параметром
console.log(Object.getOwnPropertyDescriptor(testUser, 'gender')); // Посмотреть флаги внутри объекта; 
// остальные 3 флага writable, enumerable, configurable -- false

// Когда мы вручную создаем объект, все начальные свойства (флаги у свойства) writable, enumerable, configurable -- TRUE
// Когда мы создаем объект при помощи defineProperty и НЕ указываем их, все начальные свойства (флаги у свойства) writable, enumerable, configurable -- FALSE

// ex 1) Когда пользователь заполняет свои данные, дату рождения он будет задавать 1 раз, позже ее заменить уже нельзя. Можно использовать defuneProperty

const userAlex = {
    name: 'Alex',
    surname: 'Nabokov',
    birthday: '10/10/2010',
    showMyPublicData: function () {
        console.log(`${this.name} ${this.surname}`);
    }
}
Object.defineProperty(userAlex, 'birthday', { writable: false });
console.log(Object.getOwnPropertyDescriptor(userAlex, 'birthday'));
userAlex.birthday = '11/11/2011'; // error.

// Также эти данные можно сформировать динамически. Уберем 'birthday' из объекта, и:
Object.defineProperty(userAlex, 'birthday', { value: prompt('date?'), enumerable: true, configurable: true });

// ex 2) Нужно выводить данные из объекта, но нужно получить только данные (имя, фамилия, дата рождения), без методов:

Object.defineProperty(userAlex, 'showMyPublicData', { enumerable: false });
for (let key in userAlex) console.log(key);

// Понадобилось свойство, которое после создания нельзя ни удалить, ни изменить его флаги и значение (Math(PI))

console.log(Object.getOwnPropertyDescriptor(Math, 'PI'))

// Чтобы создать такое свойство, нужно флаг configurable -> false (после этого нельзя поменять свойство)

Object.defineProperties(userAlex, { // просто множественное число, чтобы изменять множество флагов сразу
    name: { writable: false },
    surname: { writable: false }
});

// Полезные Методы у объектов (редкие и часто используемые)

// .preventExtensions() -- невозможно добавлять свойства к объекту, например чтобы посторонние данные не приходили
// .seal -- предотвращает попадение новых свойств и configurable -- false
// .freeze() -- замораживает объект (нельзя добавлять/изменять/удалять свойства) configurable, writable -- false

// .isExtensible() -- разрешено ли разширение объекта -- проверка на использование метода preventExtensions()
// .isFrozen() -- аналогично
// .isSealed()

// все эти 6 методов довольно редко используются, но специфические задачи могут быть решены только через него.

// Один объект никогда не равен другому объекту, даже если у них одинаковое содержимое. МОГУТ СПРОСИТЬ НА СОБЕСЕДОВАНИИ (СОБЕСЕ)
// но есть метод, который позволяет сравнивать содержимое объектов -- Object.is() -- являются ли два значения различимыми (одинаковыми)

// 3 популярных метода -- формировка массива из объектов
// .keys(), .values(), entries()

// .keys() возвращает массив (ключей) из собственных перечисляемых свойств переданного объекта, 
// в том же порядке, в котором они бы обходились циклом for in (разница между циклом и методом в том, что
// цикл перечисляет свойства из цепочки прототипов). ПЕРЕЧИСЛЯЕМЫЕ -- тесвойства, которые могут быть перечислены в цикле
// и у которых стоит enumerable: true.

// .values() возвращает массив (значений) перечисляемых свойств объекта в том же порядке, что и цикл for in. Разница между циклом и методом в том,
// что цикл перечисляет свойства из цепочки прототипов.

// .entries() возвращает массив собственных перечисляемых свойств указанного объекта в формате [key, value] в том же порядке, что и в цикле for in.
// Разница между циклом и методом в том, что цикл перечисляет свойства из цепочки прототипов. Порядок элементов в массиве который возвращается
// Object.entries() не зависит от того как объект заявлен. Если существует необходимость в определенном порядке, то массив должен быть отсортирован
// до вызова метода, например Object.entries(obj).sort((a, b) => a[0] - b[0]);

// .assign() доп метод

// после урока пробежаться по методам глазами. СПРАШИВАЮТ
// как из объекта создать двумерный массив (матрицу) -- ответ Object.entries()
// как создать массив только из значений -- Object.values()

// с символами в качестве свойства тоже все работает. хотя enumerable будет true, 

const birthday = Symbol('birthday');

const brainStorm = {
    name: 'test',
    [birthday]: '20/04/2021'
}

Object.defineProperty(brainStorm, 'showMyPublicData', { enumerable: false });

for (let key in brainStorm) console.log(key);
console.log(Object.getOwnPropertyDescriptor(brainStorm, birthday));

Object.defineProperties(brainStorm, {
    name: { writable: false },
    surname: { writable: false }
});


// -------------------- lesson 47 (57) --------------------

// Перебираемые (итерируемые объекты) конструкции

function Lesson57() {
    const user = {
        name: 'Alex',
        surname: 'Nabokov',
        birthday: '10/10/2010',
        showMyPublicData: function () {
            console.log(`${this.name} ${this.surname}`);
        }
    }

    for (const key in user) {
        console.log(user[key]) // Перебор объекта через for in: свойства + метод
    }

    const arr = ['b', 'a', 'c'];
    for (const key in arr) {
        console.log(arr[key]) // Перебор массива через for in: индекс элемента ('b', 'a', 'c')
    }

    const str = 'string';
    for (const key in str) {
        console.log(str[key]); // Перебор строки s t r i n g 
    }

    // Однако при переборе массивов и строк таким способом есть проблема -- перебор может идти не по порядку.
    // for in НЕОБЯЗАТЕЛЬНО ПЕРЕБИРАЕТ СВОЙСТВА ПО ПОРЯДКУ!!! И НЕ РЕКОМЕНДУЕТСЯ ПРИМЕНЯТЬ ЕГО НА МАССИВАХ И СТРОКАХ!!!

    // была введена конструкция for of (проходится по значениям перебираемого объекта)
    // отличие от for in -- он получает сам КЛЮЧ, а for of -- он получает само ЗНАЧЕНИЕ
    // Однако просто при замене for in -> for of мы получим undefined

    for (const key of arr) {
        console.log(arr[key]);
    }

    // Правильно будет оставить просто ключ и все:

    for (const key of arr) {
        console.log(key);
    }

    // Протестируем for of с нашим объектом, получим: 

    for (const key of user) {
        console.log(user[key]) // user is not iterable
    }

    // Что же такое итерируемый объект?
    // Перебираемый или итерируемый объект -- это тот, который мы можем использовать в 
    // for of (строка и массив -- итерируемые объекты, а объект -- нет)
    // Это определяется тем, есть ли у сущности 'Symbol.iterator'
    console.dir(arr); // array -> prototype -> Symbol(Symbol.iterator): values(). он ЕСТЬ, значит объект ПЕРЕБИРАЕМЫЙ
    // к ним относятся (к перебираемым объектам): Массивы, строки, типизированные массивы, set, map, DOM-Collections
    // С перебираемым объектами мы получаем два преимущества:
    // 1 -- строгое соответствие порядка в переборе
    // 2 -- исключение всех лишних свойств, которые могут быть наследованы:

    const array = ['b', 'c', 'd', 'e', 'f', 'g'];
    Array.prototype.someMethod = function () { };
    console.dir(array);
    for (const key in array) {
        console.log(key);
    } // 0 1 2 someMethod -- массив унаследовал метод из прототипа и вывел его через for in
    // При переборе for of этот метод исчезнет, то есть лишнее свойство убирается при таком способе перебора

    // Существует команда, которая называется HasOwnProperty, которая позволяет проверить, является ли свойство собственным

    // Итого -- итерируемые конструкции -- которые можно перебрать for of (по умному -- структура, которая содержит Symbol.iterator)
    // Что из себя составляет Symbol.iterator? Как его добавить к обычному объекту? СПРАШИВАЮТ НА СОБЕСЕДОВАНИЯХ / СОБЕС
    // iterator -- метод, который возвращает объект с методом next:
    // итератор нужно создавать вручную, чтобы сделать объект перебираемым

    const salaries = {
        john: 500,
        ivan: 1000,
        ann: 5000,
        sayHello: function () {
            console.log('hello');
        }
    }

    // чтобы сделать данный объект итерируемым (чтобы for of мог с ним работать), необходимо добавить в объект метод Symbol.iterator:

    salaries[Symbol.iterator] = function () { // когда цикл for of будет запускаться на объекте, то он вызывает метод Symbol.iterator ОДИН раз
        // Этот метод должен нам вернуть итератор -- объект с методом next
        return {
            current: this.john,
            last: this.ann,

            next() { // мы производим перебор зарплат каждые 500 единиц. Результат метода next() всегда ОБЪЕКТ

                if (this.current < this.last) { // условие, которое контролирует перебор
                    this.current += 500;
                    return { done: false, value: this.current } // в таком случае возвращаем объект ОБЯЗАТЕЛЬНО В ТАКОМ ВИДЕ;
                    // value: this.current -- следующее значение, которое пойдет в следующий перебор (на 500 больше)
                } else { // иначе
                    return { done: true } // вернем такой объект ОБЯЗАТЕЛЬНО В ТАКОМ ВИДЕ
                }
            }
        }
    }

    for (let res of salaries) {
        console.log(res);
    }

    // если for of при попытке вызвать метод Symbol.iterator обнаружит, что его нет, он выведет ошибку: object is not iterable

    // for of получил наш объект с методом next(). Когда наш перебор (for of) хочет получить следующее значение, он вызывает метод объекта next()
    // и результат вызова метода должен иметь определенный вид 
    // Все это реализовано в JavaScript, мы сейчас это делаем вручную, дабы понять смысл работы итерируемых объектов
    // такая логика у итераторов всегда, даже у встроенных перебираемых объектов
    // Однако такой метод подойдет к любому объекту, чтобы сделать его перебираемым (итерируемым) по нашему требованию.

    // Такой итератор можно вызывать вручную (ручной вызов метода next()), то есть написать вместо for of:

    const iterator = salaries[Symbol.iterator](); // так как это метод, мы можем его сразу вызвать
    // и в переменную 'iterator' сразу получим объект '.iterator' с методом next() и привязкой к определенному объекту
    console.log(iterator.next()); // вызываем метод next()
    // результат -- { done: false, value: 1000 }
    // можно использовать в циклах вместе с break/continue, более гибкий вариант чем for of, который идет до конца.

    // подробнее: у нас есть метод перебора (выше начинается с function() до последней скобки)
    // мы можем его запустить в salaries[Symbol.iterator] при помощи круглых скобок -> salaries[Symbol.iterator]()
    // и результат работы этого метода -- объект (внутри return), у которого есть метод next() и есть привязка к определенному объекту
    // (current/last через контекст вызова (ключевое слово) this) 

    // Итог урока -- что такое Symbol.iterator, у кого он есть
    // разница между for in и for of
    // какой объект называется итерируемым
    // как устроен итератор изнутри, как его можно создать своими руками

    // ОТВЕТЫ:
    // 1) Symbol.iterator 
    // -- метод, который возвращает объект с методом next() для перебора.

    // 2) у кого есть Symbol.iterator 
    // -- Массивы, строки, типизированные массивы, set, map, DOM-Collections

    // 3) разница между for in и for of -- 
    // for in -- это метод итерации по «перечисляемым» свойствам объекта. 
    // Таким образом, он применим ко всем объектам (не только Object()), обладающим этими свойствами.
    // for of -- это метод, представленный в ES2015, для перебора «итерируемых коллекций». Это объекты, у которых есть свойство [Symbol.iterator].
    // краткое отличие: for in -- он получает сам КЛЮЧ, а for of -- он получает само ЗНАЧЕНИЕ
    // почему так: for in НЕОБЯЗАТЕЛЬНО ПЕРЕБИРАЕТ СВОЙСТВА ПО ПОРЯДКУ!!! И НЕ РЕКОМЕНДУЕТСЯ ПРИМЕНЯТЬ ЕГО НА МАССИВАХ И СТРОКАХ!!!

    // 4) какой объект называется итерируемым -- 
    // который мы можем использовать в цикле for of или же -- это структура, которая содержит Symbol.iterator

    // 5) как устроен итератор изнутри и как его создать своими руками -- 
    // чтобы сделать данный объект итерируемым (чтобы for of мог с ним работать), необходимо добавить в объект метод Symbol.iterator:

    /*
        salaries[Symbol.iterator] = function () { // когда цикл for of будет запускаться на объекте, то он вызывает метод Symbol.iterator ОДИН раз
            // Этот метод должен нам вернуть итератор -- объект с методом next
            return {
                current: this.john,
                last: this.ann,
    
                next() { // мы производим перебор зарплат каждые 500 единиц. Результат метода next() всегда ОБЪЕКТ
    
                    if (this.current < this.last) { // условие, которое контролирует перебор
                        this.current += 500;
                        return { done: false, value: this.current } // в таком случае возвращаем объект ОБЯЗАТЕЛЬНО В ТАКОМ ВИДЕ;
                        // value: this.current -- следующее значение, которое пойдет в следующий перебор (на 500 больше)
                    } else { // иначе
                        return { done: true } // вернем такой объект ОБЯЗАТЕЛЬНО В ТАКОМ ВИДЕ
                    }
                }
            }
        }
    
        for (let res of salaries) {
            console.log(res);
        }
    
        // если for of при попытке вызвать метод Symbol.iterator обнаружит, что его нет, он выведет ошибку: object is not iterable
    
        // for of получил наш объект с методом next(). Когда наш перебор (for of) хочет получить следующее значение, он вызывает метод объекта next()
        // и результат вызова метода должен иметь определенный вид 
        // Все это реализовано в JavaScript, мы сейчас это делаем вручную, дабы понять смысл работы итерируемых объектов
        // такая логика у итераторов всегда, даже у встроенных перебираемых объектов
        // Однако такой метод подойдет к любому объекту, чтобы сделать его перебираемым (итерируемым) по нашему требованию.
    
        // Такой итератор можно вызывать вручную (ручной вызов метода next()), то есть написать вместо for of:
    
        const iterator = salaries[Symbol.iterator](); // так как это метод, мы можем его сразу вызвать
        // и в переменную 'iterator' сразу получим объект '.iterator' с методом next() и привязкой к определенному объекту
        console.log(iterator.next());
    */
}
Lesson57();

// -------------------- lesson 48 (58) --------------------

// -------------------- lesson 49 (59) --------------------

// -------------------- lesson 50 (60) --------------------

// -------------------- lesson 51 (61) --------------------

// -------------------- lesson 52 (62) --------------------

// -------------------- lesson 53 (63) --------------------

// -------------------- lesson 54 (64) --------------------

// -------------------- lesson 55 (65) --------------------

// -------------------- lesson 56 (66) --------------------

// -------------------- lesson 57 (67) --------------------

// -------------------- lesson 58 (68) --------------------

// -------------------- lesson 59 (69) --------------------

// -------------------- lesson 60 (70) --------------------

// -------------------- lesson 61 (71) --------------------

// -------------------- lesson 62 (72) --------------------

// -------------------- lesson 63 (73) --------------------

// -------------------- lesson 64 (74) --------------------

// -------------------- lesson 65 (75) --------------------

// -------------------- lesson 66 (76) --------------------

// -------------------- lesson 67 (77) --------------------

// -------------------- lesson 68 (78) --------------------

// -------------------- lesson 69 (79) --------------------

// -------------------- lesson 70 (80) --------------------

// -------------------- lesson 71 (81) --------------------

// -------------------- lesson 72 (82) --------------------

// -------------------- lesson 73 (83) --------------------

// -------------------- lesson 74 (84) --------------------

// -------------------- lesson 75 (85) --------------------

// -------------------- lesson 76 (86) --------------------

// -------------------- lesson 77 (87) --------------------

// -------------------- lesson 78 (88) --------------------

// -------------------- lesson 79 (89) --------------------

// -------------------- lesson 80 (90) --------------------

// -------------------- lesson 81 (91) --------------------

// -------------------- lesson 82 (92) --------------------

// -------------------- lesson 83 (93) --------------------

// -------------------- lesson 84 (94) --------------------

// -------------------- lesson 85 (95) --------------------

// -------------------- lesson 86 (96) --------------------

// -------------------- lesson 87 (97) --------------------

// -------------------- lesson 88 (98) --------------------

// -------------------- lesson 89 (99) --------------------

// -------------------- lesson 90 (100) --------------------

// -------------------- lesson 91 (101) --------------------

// -------------------- lesson 92 (102) --------------------

// -------------------- lesson 93 (103) --------------------

// -------------------- lesson 94 (104) --------------------

// -------------------- lesson 95 (105) --------------------

// -------------------- lesson 96 (106) --------------------

// -------------------- lesson 97 (107) --------------------

// -------------------- lesson 98 (108) --------------------

// -------------------- lesson 99 (109) --------------------

// -------------------- lesson 100 (110) --------------------

// -------------------- lesson 101 (111) --------------------

// -------------------- lesson 102 (112) --------------------

// -------------------- lesson 103 (113) --------------------

// -------------------- lesson 104 (114) --------------------

// -------------------- lesson 105 (115) --------------------

// -------------------- lesson 106 (116) --------------------

// -------------------- lesson 107 (117) --------------------

// -------------------- lesson 108 (118) --------------------

// -------------------- lesson 109 (119) --------------------

// -------------------- lesson 110 (120) --------------------

// -------------------- lesson 111 (121) --------------------

// -------------------- lesson 112 (122) --------------------

// -------------------- lesson 113 (123) --------------------

// -------------------- lesson 114 (124) --------------------

// -------------------- lesson 115 (125) --------------------

// -------------------- lesson 116 (126) --------------------

// -------------------- lesson 117 (127) --------------------

// -------------------- lesson 118 (128) --------------------

// -------------------- lesson 119 (129) --------------------

// Чтобы вручную не писать номера у уроков, можно попробовать сделать это:

for (let i = 47; i < 82; i++) {
    console.log('// -------------------- lesson ' + i + ' ' + '(' + (i + 10) + ')' + ' --------------------' + '\n');
}



/*
1) Функция isOpen не хочет правильно работать. Что мы уже не пробовали
подставлять в неё - результат все время неправильный. 
Необходимо найти причины и исправить.

2) Функция isAverageLunchPriceTrue должна брать цены двух любых блюд 
из меню, складывать их и сравнивать с средним чеком (averageLunchPrice).

Сейчас функция работает, но постоянно выдает неправильный результат. 
Ведь из представленного меню сумма двух любых цен всегда будет больше 
20. Необходимо найти причину и исправить.

3) Функция transferWaitors создана для того, чтобы копировать шаблон 
данных и передавать их в другой ресторан. Конечно, в другом ресторане 
будут другие блюда, другие официанты и тп. Сейчас эта функция только в 
начале разработки и должна менять данные про официантов.

Но в нынешнем виде мы обнаружили, что после её запуска не только 
копия данных содержит новых официантов, но и основные данные! 
В restorantData сотрудник Alice исчезает и заменяется Mike! 
Необходимо найти причину и немедленно исправить, чтобы данные были разделены.
*/

const restorantData = {
    menu: [
        {
            name: 'Salad Caesar',
            price: '14$'
        },
        {
            name: 'Pizza Diavola',
            price: '9$'
        },
        {
            name: 'Beefsteak',
            price: '17$'
        },
        {
            name: 'Napoleon',
            price: '7$'
        }
    ],
    waitors: [
        { name: 'Alice', age: 22 }, { name: 'John', age: 24 }
    ],
    averageLunchPrice: '20$',
    openNow: true
};

function isOpen(prop) {
    let answer = '';
    prop ? answer = 'Открыто' : answer = 'Закрыто';
    return answer;
}

console.log(isOpen(restorantData.openNow))

function isAverageLunchPriceTrue(fDish, sDish, average) {
    if (+fDish.price.slice(0, -1) + (+sDish.price.slice(0, -1)) < +average.slice(0, -1)) {
        return 'Цена ниже средней';
    } else {
        return 'Цена выше средней';
    }
}

console.log(isAverageLunchPriceTrue(restorantData.menu[0], restorantData.menu[1], restorantData.averageLunchPrice));

function transferWaitors(data) {
    const copy = Object.assign({}, data);

    copy.waitors = [{ name: 'Mike', age: 32 }];
    return copy;
}

console.log(transferWaitors(restorantData));

