// -------------------- lesson 1 -------------------- 
console.log(1);
"use strict"; // Современный режим (строгий)
// новая директива, современный код

let numberLesson1 = 5;
// let - объявление переменной (let), имя (numberLesson1), присваивание (=), значение (5)
const leftBorderWidth = 1;
// leftBorderWidth = 2;
console.log(leftBorderWidth);
// ширина левой границы 
// Переменная может начинаться с букв, 
// нижнего подчеркивания и доллара, также нельзя использовать слова error, 
// alert и тд (зарезервированные)
// console.log(1);
let number = 11;
number = 10;
console.log(number);

const obj = {
    a: 50
};
obj.a = 10;
console.log(obj);
// прямых констант не бывает!


// var name = 'Ivan' старый метод переменной, существует до того, как была объявлена в коде (Поднятие/всплытие (hoisting))


// особенность let:

// Неправильно, будет ошибка, работает внутри скобок

{
    let result1 = 50;
}
console.log(result1);

// Правильно

{
    let result = 50;
console.log(result); }


// less2

// Styles:
// snake_case -- один из вариантов названия папок и файлов
// UPPER_SNAKE_CASE -- вариант написания переменных в виде констант (цвета, )
// Kebab-case -- папки, файлы
// PascalCase -- классы
// camelCase -- переменные

let vehicleBodyWidth = 5000;
let vehicleBodyLength = 4000;

vehicleBodyWidth = 5000;
vehicleBodyLength = 4000;
console.log("Ширина кузова автомобиля: " + vehicleBodyWidth + ', длина: ' + vehicleBodyLength);





// ------------------------------ Homework #1 ------------------------------

// Создайте переменную, которая будет отображать имя пользователя. (Пользователь - user, имя - name). В неё поместите значение "John"
// На следующей строке создайте переменную, отображающую номер пользователя (номер - number). В неё поместите значение 25.
// Измените значение второй переменной с 25 на 24 на следующей строке.


const userName = "John";
let userNumber = 25;
userNumber = 24;





// -------------------- lesson 2 -------------------- 

// Типы данных в JS:
// Простые типы:

// Числа 1, 2, 3 (Infinity (+/-) - console.log(4/0), Not a Number (string * 9) - NaN - не число, нет мат логики)
let numberLesson2 = 4.6;
console.log(4/0);
console.log('string' * 9);

// Строки 'string', "name", либо тильда `name`
const person = "Alex";

// Логический тип (boolean) true/false
const bool = true;

// null - не существует
let something;
console.log(something);

// undefined - существует, но нет значения
let und;
console.log(und);

// Symbol

// BigInt - большие числа (> 2^53 - 1)
// Тип BigInt может быть определен с помощью оператора typeof:

// typeof 123;
// --> 'number'
// typeof 123n;
// --> 'bigint'



// Объекты (комплексные):
const object = {
    name: "John", // ключ (свойства) + значение
    age: 25, // данные -- свойства объекта, действия -- методы
    isMarried: false
};

console.log(object.name); // обращение к определенному свойству (данным) в объекте
console.log(object["name"]);

// 1) Спец. объекты 2) Обычные объекты

// Массивы [] ЧАСТНЫЙ СЛУЧАЙ ОБЪЕКТА, не является отдельным типом данных
let array = ['plum.png', 'orange.jpeg', 'apple.bmp', 6, [], {}];
console.log(array[1]); // только значение, нет ключа (он фиксирован, задан по умолчанию)
console.log(array[0]);
console.log(array[4]);

// Function


// Объект даты


// Регулярные выражения


// Ошибки


// -------------------- lesson 3 -------------------- 

// Разница между массивами и объектами
const arr = [1, 2, 3]; // Массив -- Перечень информации по порядку
const arrObj = { // Объект -- Структура хранения данных в парном формате
    a: 1,
    1: 2,
    2: 3
};

console.log(arr[1]);
console.log(arrObj.a);
console.log(arrObj[1]);

arrObj.bounty = '1337';
arrObj['bountyR'] = '228';
console.log(arrObj['bounty']); // Указание свойства, а не переменной
console.log(arrObj.bounty); // Обращение к свойству
console.log(arrObj['bountyR']);

// Можно и так, главное, чтобы переменная уже существовала
const b = 'b' // Если есть переменная, которая содержит определенное значение
// По сути, это динамические данные в объекте. В массиве можно также, но...
arr[10] = '345678';
console.log(arr[10]); // Нарушает логику, в массиве будет 7 пустых элементов
// Да, можно, но не нужно.

arrObj[b] = '1234'; // То можно ее использовать, чтобы создать новое свойство
console.log(arrObj['b']);
console.log(arrObj[b]);

// Внутри объектов можно создавать вложенные структуры (пример-фильмы/жанры):
const arrayObjectLess3 = {
    a: 'a',
    '1': 'b',
    2: 'c',
    abc: {
        df: [{}, {}],
        def: {

        }
    }
};


const objectLess3 = {a: 1, c: 2}; // Структура хранения данных в парном формате

const objectLesson3 = {
    'Anna': 500,
    'Alice': 800
};

// Вот так плохо!  ['Anna', 500, 'Alice', 800]


// ------------------------------ Homework #2 ------------------------------

/* Создайте переменную с названием магазина (магазин - store, имя - name) и поместите в неё любое название на ваш выбор.
Создайте объект под названием storeDescription
во внутрь этого объекта напрямую поместите свойство budget и укажите его как 10000. 
Напрямую - это сразу внутри фигурных скобок, мы его расширяем на месте
Во внутрь объекта storeDescription напрямую поместите свойство employees. 
Это должен быть массив, который содержит имена трех сотрудников на ваш выбор
Во внутрь объекта storeDescription напрямую поместите свойство products. 
Это должен быть тоже объект, который содержит два товара и их цену. 
То есть, нужно создать пару ключ-значение в виде товар: цена. Данные на ваш выбор.
Во внутрь объекта storeDescription напрямую поместите свойство open. 
Тут можно контролировать: или магазин открыт, или закрыт, то есть логическое значение. Сделайте его открытым
*/



const storeName = "YSN";
const storeDescription = {
    budget: 10000,
    employees: ['Dasha', 'Artyom', 'Arseny'],
    products: {
        potatoes: 80,
        tomatoes: 150,
    },
    open: true
};

console.log(storeDescription['budget']);



// -------------------- lesson 4 -------------------- 

alert('Hello') // Встроенное в браузер окно. Предупреждение пользователя

const resultLess4 = confirm('Are u here?'); // Такое же окно с двумя вариантами ответа
console.log(resultLess4); // Запись результата true/false в консоль
const answer1 = prompt('Вы программист?', '');
console.log(typeof(answer1)); // Узнать тип данных
// Вся информация, приходящая от пользователя - СТРОКА!

const answer2 = +prompt('Вы программист?', ''); // Динамическая типизация
// Преобразование типа данных "строка" в "число"

const answer3 = prompt('Вы программист?', '');
console.log(typeof(answer3 + 5)); // Сложение строк: 10+5=105

const answer4 = +prompt('Вы программист?', '');
console.log(typeof(answer4 + 5)); // Сложение чисел: 10+5=15


// Зададим список вопросов, поместив их в массив
const answers = [];
answers[0] = prompt('Ваше имя', ''); // prompt существует в браузере!
answers[1] = prompt('Ваша фамилия', ''); // Это не переменная
answers[2] = prompt('Ваше отчество', ''); // Также с alert, confirm

document.write(answers); // Замена содержимого на то, что выводим
/* Однако 'Hello world' останется, т.к тег body пуст, не сформирован.
prompt, alert, confirm блокируют построение страницы до их выполнения
*/
console.log(typeof(answers)); // Объект! т.к массив - частный случай
// Однако есть ошибка console.log(typeof(null)); -- выведет object



// -------------------- lesson 5 (13) -------------------- 
// Интерполяция

const category = 'toys';

console.log('https://someurl.com/' + category + '/' + '4'); // Не круто

// Используем интерполяцию
console.log(`https://someurl.com/'${category}/5`); // Такой же результат

// Кавычки ТОЛЬКО ЧЕРЕЗ ТИЛЬДУ (бэктики)
const user = 'Artyom';
alert(`Привет, ${user}`);






// -------------------- lesson 6 (14) -------------------- 
// Операторы js

// Сложение

console.log('array' + " — object") // Сложение строк = 'array — object'
console.log('array' + +" — object") // Сложение строки с числом (унарный плюс) = 'NaN'
console.log('array' + 5) // Сложение строки с числом -- конкатенация. Результат -- строка
console.log('4' + +"5") // Сложение строки с числом (унарный плюс) = '45'
console.log('4' + 5) // Сложение строки с числом = '45'
console.log(4 + 5) // Сложение числа с числом = '9'

// Инкремент и декремент

let incr = 10,
    decr = 10;

incr++; // Увеличение на единицу (постфиксная форма записи). Префиксная '++incr;'
decr--; // Уменьшение на единицу (постфиксная форма записи). Префиксная '--decr;'

/* Разница в том, что при использовании постфиксной формы СРАЗУ (например, в console.log),
то она вернет старое значение. Использовал -> Старое значение -> Увеличение/уменьшение
Префиксная сразу же меняет. ТО ЕСТЬ:

ПРЕФИКСНАЯ форма возвращает новое значение, 
в то время как ПОСТФИКСНАЯ форма возвращает старое (до увеличения/уменьшения числа).
*/

/* 
console.log(incr++);
console.log(decr--);

Вывод: 10, 10


console.log(++incr);
console.log(--decr);

Вывод: 11, 9
*/

console.log(incr);
console.log(decr);

// Остаток от деления

console.log(5%2); // 1

// Равенство (==), ПРИСВАИВАНИЕ (=)

console.log(2*4 == 8); // true, сравнение ПО ЗНАЧЕНИЮ, а не по типам данных. можно сравнить число со строкой
console.log(2*4 === '8'); // Строгое сравнение (с типами данных). false

// Оператор И (&&)
// Оператор ИЛИ (||)
// Отрицание (!)

const isChecked = true,
      isClose = true;


console.log(isChecked && isClose); // true; 'isClose' = true, 'isChecked' = true.
console.log(isChecked || isClose); // true; 'isClose' = true, 'isChecked' = true.
console.log(isChecked || !isClose); // true; '!isClose' = false, 'isChecked' = true.


// Порядок выполнения операторов (приоритет)

/*
Чем больше приоритет (18 > 1), тем он выше

1) Запятая, последовательность (слева направо) '… , …'

2) Присваивание (=), 
Условный (тернарный) оператор (?), 
yield, 
yield* (СПРАВА НАЛЕВО) '… = …' '… ? … : …' 'yield …'

3) Логическое ИЛИ (||), 
Оператор нулевого слияния (??) (слева направо) '… || …' '… ?? …' 

4) Логическое «И» (&&) (слева направо) '… && …'

5) Побитовое «ИЛИ» (|) (слева направо) '… | …'

6) Побитовое исключающее «ИЛИ» (^) (слева направо) '… ^ …'

7) Побитовое «И» (&) (слева направо) '… & …'

8) Равенство (==), 
Неравенство (!=), 
Строгое равенство (===), 
Строгое неравенство (!==) (слева направо) '… == …' '… != …'

9) Меньше (<), 
Меньше или равно (<=), 
Больше (>), 
Больше или равно (>=), 
in, 
instanceof (слева направо) '… < …' '… <= …'

10) Побитовый сдвиг влево/вправо (<< / >>), 
Сдвиг вправо с заполнением нулей (>>>) (слева направо) '… << …' 

11) Сложение/Вычитание (+ / -) (слева направо) '… + …'

12) Умножение (*), Деление (/), Остаток от деления (%) (слева направо) '… * …' '… / …'

13) Возведение в степень (**) (СПРАВА НАЛЕВО) '… ** …'

14) Логическое отрицание (!), 
Побитовое отрицание (~), 
Унарный плюс/минус, 
Префиксный инкремент/декремент, 
typeof, 
void, 
delete, 
await (СПРАВА НАЛЕВО) '! …' '~ …'

15) Постфиксный инкремент/декремент (НЕ ОПРЕДЕЛЕНО) '… ++' '… --'

16) new (без списка аргументов) (СПРАВА НАЛЕВО) 'new …'

17) Доступ к свойствам (слева направо) '… . …', 
Доступ к свойствам с возможностью вычисления (слева направо) '… [ … ]', 
new (со списком аргументов) (НЕ ОПРЕДЕЛЕНО) 'new … ( … )', 
Вызов функции (слева направо) '… ( … )', 
Оператор опциональной последовательности (?.) (слева направо) '?.'

18) Группировка (НЕ ОПРЕДЕЛЕНО) '( … )'

*/


// -------------------- lesson 7 (15) -------------------- 

/* Система контроля версий Git. Сервис GitHub

Курс git — https://githowto.com/ru
git init — инициализация репозитория
Далее - настройка системы Git для отображения изменений
git config — конфигурация локально (указание другого имени, не распространяются на глобальные)
глобально (на весь ПК от нашего имени)  
git config --local user.name "Artem"
git config --local user.email example@gmail.com
git status — статус репозитория (commits - контрольные точки)
git add -A — добавить все файлы (add 'writeFileName' or '*.css' - все .css файлы)
git commit -a -m"first commit" — добавить контрольную точку, message, "..." - краткое содержание, что было сделано на этом commit'е
git log — когда и кем выполнены коммиты
*/


// -------------------- lesson 8 (16) -------------------- 

/* Продолжение Git. gitignore, Git Kraken 
cd - — (change directory) Вернуться назад
cd .. — Выйти на 1 уровень вверх
cd ../.. — Выйти на 2 уровня вверх
cd 'work' — Выйти в папку work
git clone 'URL' 'name folder' — клонирование репозитория на ПК в нужную папку
git pull — обновление старого файла на новый (используется для извлечения и загрузки содержимого из удаленного хранилища и 
немедленного обновления локального хранилища в соответствии с этим содержимым) — подгрузка из GitHub и обновление файла
Изменили проект (другой человек) - сразу пишем git pull!
Иначе будет ошибка, тогда:

git push --- error
git pull
'пишем коммит, т.к 2 проекта (с моего ПК (локальный репозиторий) и удаленного репозитория - merge'
ctrl + C дважды
:
wq! (write and quit)

!!!!!! Всего этого не будет, если сразу написать git pull

git fetch ПИЖЖЕ ЧЕМ pull

gitignore — часть файлов не надо пушить каждый раз на репозиторий. https://help/github/com/ignore-files/
GitKraken — удобный, красивый интерфейс для просмотра репозиториев 
*/


// -------------------- lesson 9 (17) -------------------- 

/* Подключение ПК к github через SSH (Secure shell) 
HTTP — HyperText Transfer Protocol
SSL certificate — secure sockets layer
FTP — File Transfer Protocol
SSH — Secure shell - удаленное управление ОС и передача файлов

Плюсы HTTPS:
1. Проще (логин+пароль)
2. Доступ к сервису через авторизацию
3. Порт в ОС открыт
Минусы:
1. Ввод логин+пароль (изменение пароля - новый ввод)
2. Украли логин+пароль - плохо

Плюсы SSH:
1. Есть пара ключей - автоматическая авторизация
2. Ключи безопаснее за счет их размера (длина)
3. Первая настройка - простое подключение других устройств и ОС
4. Украли ключ - только смена информации в репозиториях
Минусы:
1. Первоначальная настройка не быстрое дело
2. Порт может быть заблокирован брандмауэром 
Подключение SSH: https://docs.github.com/en/authentication/connecting-to-github-with-ssh 
*/


// -------------------- lesson 10 (18) -------------------- 

/* Практическое задание 
1) Создать переменную numberOfFilms, в нее поместить ответ от пользователя на вопрос:
'Сколько фильмов вы уже посмотрели?'

let numberOfFilms = prompt('Сколько фильмов вы уже посмотрели?', '');
const personalMovieDB = {
    count: numberOfFilms,
    movies: {},
    actors: {},
    genres: [],
    private: false
};
const lastMovieYouWatched = prompt('Один из последних просмотренных фильмов?', '');
const scoreLastMovie = prompt('На сколько оцените его?', '');
console.log(lastMovieYouWatched);
console.log(scoreLastMovie);

personalMovieDB.movies.lastMovieYouWatched = prompt('Один из последних просмотренных фильмов?', '');
personalMovieDB.movies.scoreLastMovie = prompt('На сколько оцените его?', '');


2) Создать объект personalMovieDB и в него поместить свойства:
    — count — передается ответ на первый вопрос
    — movies — в это свойство поместить пустой объект
    — actors — тоже поместить пустой объект
    — genres — поместить пустой массив
    — private — поместить boolean значение false

3) Задайте пользователю по 2 раза вопросы:
    — 'Один из последних просмотренных фильмов?'
    — 'На сколько оцените его?'
Ответы стоит поместить в отдельные переменные.
Записать ответы в объект movies в формате:
    movies: {
        'logan': '8.1'
    }
Проверить, чтобы все работало без ошибок в консоли
*/

let numberOfFilms = prompt('Сколько фильмов вы уже посмотрели?', '');
const personalMovieDB = {
    count: numberOfFilms,
    movies: {},
    actors: {},
    genres: [],
    privat: false
};

// const lastMovieYouWatched = prompt('Один из последних просмотренных фильмов?', '');
// const scoreLastMovie = prompt('На сколько оцените его?', '');
// console.log(lastMovieYouWatched);
// console.log(scoreLastMovie);

personalMovieDB.movies.lastMovieYouWatched = prompt('Один из последних просмотренных фильмов?', '');
personalMovieDB.movies.scoreLastMovie = prompt('На сколько оцените его?', '');

personalMovieDB.movies.lastMovieYouWatched = prompt('Один из последних просмотренных фильмов?', '');
personalMovieDB.movies.scoreLastMovie = prompt('На сколько оцените его?', '');



// -------------------- lesson 11 (19) -------------------- 
// Условия

if (4 == 9) {
    console.log('ok');
} else {
    console.log('error');
}

// Вложенные условия

const num = 50;
if (num < 49) {
    console.log('error');
} else if (num > 100) {
    console.log('too much');
} else {
    console.log('okay');
}

// Тернарный оператор
// Если условие (num === 50) выполнилось, то идет действие в случае правдивого условия : пишем действие, которое выполнится, если (num === 50) не выполнилось
(num === 50) ? console.log('okay') : console.log('error');

// switch (конструкция идет на СТРОГОЕ сравнение)
// Можно работать и со строками '49'
switch (num) {
    case 49:
        console.log('no');
        break;
    case 100:
        console.log('no');
        break;
    case 50:
        console.log('yes');
        break;
    default:
        console.log('not today');
        break;
}

// -------------------- lesson 12 (20) -------------------- 

// Логические операторы

// Оператор И (&&) (ПРИМ 1)

const hamburger = true,
      fries = true;

if (hamburger && fries) {
    console.log('yum')
}

console.log((hamburger && fries));

// Поменяем пример с количеством (динамическая типизация -- переход одного типа данных в другой, 
// строка может стать числом и наоборот; что угодно может стать логическим значением)

const hamburger1 = 5,
      fries1 = 0;

if (hamburger1 && fries1) {
    console.log('yum')
}

console.log((hamburger1 && fries1));

/*
5 сущностей, которые всегда будут false:
1) 0
2) "" (пустая строка БЕЗ пробела внутри)
3) null
4) undefined
5) NaN

*/

// Усложним пример с гамбургером. 3 человека заходят в заведение
// Каждый хочет съесть по 1 гамбургеру, но один человек захочет И картошку

// Решение

const hamburger2 = 2,
      fries2 = 1;

if (hamburger2 === 3 && fries2) { // Можно записать 'fries2 === 1' or 'fries2 >= 1', 'fries' тоже подойдет
    console.log('yum')
} else {
    console.log('not yum, we are leaving')
};

console.log((hamburger2 && fries2));

/* 
Когда мы запускали ПРИМ 1 с true/false, в консоли мы получали true/false. Однако если вывести в консоль

const hamburger3 = 3,
      fries3 = 1,
      cola3 = 0;

console.log((hamburger3 === 3 && cola && fries3));

Вывод консоли -- 0. Логические операторы (Оператор 'И' &&) возвращают в консоль первое ложное значение,
на котором они остановились. Если все значения правдивы -- вывод в консоль последнего значения.

----- (И запинается на лжи, ИЛИ запинается на правде :) ) -----

Для практики можно создавать бесконечное количество примеров с алгеброй логики

ПОВТОРИМ, что в JS есть 5 сущностей, которые всегда будут false:
1) 0
2) "" (пустая строка БЕЗ пробела внутри)
3) null
4) undefined
5) NaN

То есть:
console.log(0 && 5); -- вывод 0, 0 это неправда, выводим первое, на чем "споткнулись"
console.log(null && 'fgdnfdlgkfd'); -- вывод null, null это неправда, выводим первое, на чем споткнулись
console.log(1 && 5); -- вывод 5, оба числа правдивы, выводим последнее
console.log('fdijfidjdfjd' && 0); -- вывод 0, 0 это неправда, выводим первое, на чем "споткнулись"

*/

// Комбинации операторов
// Пример: то же заведение, необходимо:
// ИЛИ 3 гамбургера И 2 колы ИЛИ 3 картошки фри И хотя бы 1 порция наггетсов

const hamburger4 = 3,
      cola4 = 3,
      fries4 = 0,
      chickenNuggets4 = 2;

if ((hamburger4 === 3 && cola4 == 2) || (fries4 === 3 && chickenNuggets4)) {
    console.log('nice');
} else {
    console.log('not good')
};

// Вывод в консоль 'nice'
// Если console.log((hamburger4 === 3 && cola4 == 2) || (fries4 === 3 && chickenNuggets4)); -- вывод 2

// Оператор 'НЕ'
// Аргумент превращается в логический тип данных (true/false), затем возвращает противоположное значение
// То есть console.log(!0); -- '0' это 'false', отрицание 'false' --> 'true', вывод в консоль 'true'

// ------------------------------ Homework #3 ------------------------------

// #1. Что выведется в консоль (логические выражения)?

console.log( NaN || 2 || undefined ); // 2

console.log( NaN && 2 && undefined ); // NaN

console.log( 1 && 2 && 3 ); // 3

console.log( !1 && 2 || !3 ); // false

console.log( 25 || null && !3 ); // 25

console.log( NaN || null || !3 || undefined || 5); // 5

console.log( NaN || null && !3 && undefined || 5); // 5

console.log( 5 === 5 && 3 > 1 || 5); // true

// Последний пример эквивалентен данному примеру ниже, так как правая часть (до оператора ИЛИ -- true)
// Вывод в консоль первой правды, то есть -- 'true'

console.log (true || 5);


// #2. Выполняется ли условие?

const hamburger5 = 3;
const fries5 = 3;
const cola5 = 0;
const nuggets5 = 2;

if (hamburger5 === 3 && cola5 || fries5 === 3 && nuggets5) {
   console.log('Done!')
}

// Да
// false || true -- true

// #3. Выполняется ли условие?

let hamburger6;

/* 
Переменная hamburger задана через let, так как const подразумевает 
какое-либо начальное значение. С 'const' будет ошибка, можете проверить.
А без значения там undefined
*/

const fries6 = NaN;
const cola6 = 0;
const nuggets6 = 2;

if (hamburger6 || cola6 || fries6 === 3 || nuggets6) {
   console.log('Done!')
}

// Да

// #4. Выполняется ли условие?

let hamburger7;
const fries7 = NaN;
const cola7 = 0;
const nuggets7 = 2;

if (hamburger7 && cola7 || fries7 === 3 && nuggets7) {
   console.log('Done!')
}

// Нет

// -------------------- lesson 13 (21) -------------------- 

// Циклы

// Цикл while -- пока (условие) -- делай то-то

let number13 = 50;
while (number13 < 55) {
    console.log(number13);
    num++;
}

// Цикл do --  цикл что-то делает, а потом проверяет условие, если необходимо - выйдет из цикла

do {
    console.log(number13);
    num++;    
}
while (number13 < 55);

// Цикл for

for (let i = 1; i < 10; i++) {
    if (i === 6) {
        break;
        // continue;
    }
    console.log(i);
}
// -------------------- lesson 14 (22) -------------------- 

// Цикл в цикле и метки

for (let i = 0; i < 3; i++) {
    console.log(i);
    for (let j = 0; j < 3; j++) {
        console.log(j);
    }
}

// При помощи циклов сделать треугольник с использованием астериска (*)
// *
// **
// ***
// ****
// *****
// ******

let res = '';
const length = 7;

for (let i = 1; i < length; i++) {
    for (let j = 0; j < i; j++) {
        res += '*';
    }
    res += '\n';
}

console.log(res);


// Как из внутреннего цикла перейти к следующему, минуя остаточные итерации?

mark: for (let i = 0; i < 3; i++) {
    console.log('first: ${i}');
    for (let j = 0; j < 3; j++) {
        console.log('second: ${j}');
            for (let k = 0; k < 3; k++) {
                if (k === 2) continue mark; // метка работает и с 'break'
                console.log('third: ${k}');
        }
    }
}


// ------------------------------ Homework #4 ------------------------------

/*Задачи:

1) При помощи цикла выведите числа от 5 до 10 в консоль. 
5 и 10 включительно. Цикл можно использовать любой

2) При помощи цикла for вывести числа от 20 до 10 в консоль. 
В обратном порядке (20, 19, 18...). Когда цикл дойдет до числа 
13 - остановить весь цикл

3) При помощи цикла for выведите чётные числа от 2 до 10 включительно

4) Перепишите цикл  for на вариант с while. Результат должен 
остаться точно таким же. Не создайте бесконечный цикл! 
Иначе браузер может зависнуть. 

Цикл, который нужно переписать:
 
for (let i = 2; i <= 16; i++) {
    if (i % 2 === 0) {
        continue;
    } else {
        console.log(i);
    }
}

5) Заполните массив цифрами от 5 до 10 включительно. Помните, что 
элементы массива можно сформировать так же, как и обращаться к ним: arr[0]

*/

// Решение
// При помощи цикла выведите числа от 5 до 10 в консоль. 
// 5 и 10 включительно. Цикл можно использовать любой

// Место для первой задачи
function firstTask() {
    // Пишем решение вот тут
    for (let i = 5; i < 11; i++) {
        console.log(i);
    }
    
}

// 2) При помощи цикла for вывести числа от 20 до 10 в консоль. 
// В обратном порядке (20, 19, 18...). Когда цикл дойдет до числа 
// 13 - остановить весь цикл

// Место для второй задачи
function secondTask() {
    // Пишем решение вот тут
    for (let i = 20; i > 9; i--) {
        if (i === 13) break 
        else {
            console.log(i);
        }
    }
    
}

// 3) При помощи цикла for выведите чётные числа от 2 до 10 включительно

// Место для третьей задачи
function thirdTask() {
    // Пишем решение вот тут
    for (let i = 2; i < 11; i++) {
        if (i % 2 == 0) {
            console.log(i);
        }
    }
    
}

// Место для четвертой задачи

// 4) Перепишите цикл  for на вариант с while. Результат должен 
// остаться точно таким же. Не создайте бесконечный цикл! 
// Иначе браузер может зависнуть. 


// Цикл, который нужно переписать:

// for (let i = 2; i <= 16; i++) {
//     if (i % 2 === 0) {
//         continue;
//     } else {
//         console.log(i);
//     }
// }

function fourthTask() {
    // Пишем решение вот тут
    let i = 2;
    while (i <= 16) {
        if (i % 2 === 0) {
            i++;
            continue; 
        } else {
            console.log(i);
            i++;
        }
    }
    
}

// Место для пятой задачи

// 5) Заполните массив цифрами от 5 до 10 включительно. Помните, что 
// элементы массива можно сформировать так же, как и обращаться к ним: arr[0]

/* 
P.S. В задаче не сказано об этом, однако при записи данных в массив при помощи
arrayOfNumbers[i] = i; возникает 5 пустых элементов в начале, что неверно
Поэтому [i] заменяем на [i - 5]
*/

function fifthTask() {
    const arrayOfNumbers = [];

    // Пишем решение вот тут
    for (let i = 5; i < 11; i++) {
        arrayOfNumbers[i - 5] = i;
        console.log(arrayOfNumbers);
    }
    
    
    // Не трогаем
    return arrayOfNumbers;
}


// ------------------------------ Homework #5 ------------------------------

/*Задачи:

1) Заполните новый массив (result) числами из старого (arr). 
Количество элементов в массиве можно получить как 
arr.length, а к элементам обращаемся все так же: 
arr[0], arr[1] и тд.
Должен получиться точно такой же массив

2) Измените данный массив так, чтобы все числа 
были увеличены в 2 раза, а если попадается 
строка - то к ней было добавлено " - done".
Для определения типа данных используйте typeof();
Должно получиться: [ 10, 20, 'Shopping - done', 40, 'Homework - done' ]

3) Разверните массив data наоборот при помощи цикла 
и запишите данные в массив result.
Должно получиться: [ 'Homework', 20, 'Shopping', 10, 5 ]
*/

// Решение

// Место для первой задачи
function firstTask() {
    // Значения массива менять нельзя, тут он проверяется автоматически именно на эти значения
    const arr = [3, 5, 8, 16, 20, 23, 50];
    const result = [];

    // Пишем решение вот тут
    for (let i = 0; i < arr.length; i++) {
        result[i] = arr[i];

    }    
        console.log(result);   
    // Не трогаем
    return result;
}

// Место для второй задачи

/* 2) Измените данный массив так, чтобы все числа 
были увеличены в 2 раза, а если попадается 
строка - то к ней было добавлено " - done".
Для определения типа данных используйте typeof();
Должно получиться: [ 10, 20, 'Shopping - done', 40, 'Homework - done' ] */

function secondTask() {
    // Значения массива менять нельзя, тут он проверяется автоматически именно на эти значения
    const data = [5, 10, 'Shopping', 20, 'Homework'];

    // Пишем решение вот тут
    for (let i = 0; i < data.length; i++) {
        if (typeof(data[i]) === 'number') {
            data[i] = data[i] * 2;
        } else {
            if (typeof(data[i]) === 'string') {
                data[i] = data[i] + ' - done';
            }
        }
    }
    console.log(data);
    // Не трогаем
    return data;
}

/* 
3) Разверните массив data наоборот при помощи цикла 
и запишите данные в массив result.
Должно получиться: [ 'Homework', 20, 'Shopping', 10, 5 ]
*/

// Место для третьей задачи
function thirdTask() {
    // Значения массива менять нельзя, тут он проверяется автоматически именно на эти значения
    const data = [5, 10, 'Shopping', 20, 'Homework'];
    const result = [];

    // Пишем решение вот тут
    for (let i = 1; i <= data.length; i++) {
        result[i - 1] = data[data.length - i];
    }
    console.log(result);
    // Не трогаем
    return result;
}





// ПЕРЕРЕШАТЬ САМОМУ СНОВА

// 3) При помощи цикла for выведите чётные числа от 2 до 10 включительно

for (let i = 2; i < 11; i++) {
    if (i % 2 === 0) {
        console.log(i);
    }
}

// 4) Перепишите цикл  for на вариант с while. Результат должен 
// остаться точно таким же. Не создайте бесконечный цикл! 
// Иначе браузер может зависнуть. 
// Цикл, который нужно переписать:

// for (let i = 2; i <= 16; i++) {
//     if (i % 2 === 0) {
//         continue;
//     } else {
//         console.log(i);
//     }
// }

let i = 2;
while (i <= 16) {
    if (i % 2 === 0) {
        i++;
        continue;
    } else {
        console.log(i);
        i++;
    }
} 

// 5) Заполните массив цифрами от 5 до 10 включительно. Помните, что 
// элементы массива можно сформировать так же, как и обращаться к ним: arr[0]

const arrayOfNumbers = [];

    // Пишем решение вот тут
    const result = [];
    for (let i = 5; i < 11; i++) {
        result[i - 5] = i;
    }
    console.log(result);
    
    // Не трогаем
return arrayOfNumbers;





/* 1) Заполните новый массив (result) числами из старого (arr). 
Количество элементов в массиве можно получить как 
arr.length, а к элементам обращаемся все так же: 
arr[0], arr[1] и тд.
Должен получиться точно такой же массив */

    const arr123 = [3, 5, 8, 16, 20, 23, 50];
    const result123 = [];

    // Пишем решение вот тут
    for (let i = 0; i < arr123.length; i++) {
        result123[i] = arr123[i];
    }
    console.log(result123);
    // Не трогаем
    return result123;

/* 2) Измените данный массив так, чтобы все числа 
были увеличены в 2 раза, а если попадается 
строка - то к ней было добавлено " - done".
Для определения типа данных используйте typeof();
Должно получиться: [ 10, 20, 'Shopping - done', 40, 'Homework - done' ] */

    const data111 = [5, 10, 'Shopping', 20, 'Homework'];

    // Пишем решение вот тут
    for (let i = 0; i < data111.length; i++) {
        if (typeof(data111[i]) == 'number') {
            data111[i] = data111[i] * 2;
        } 
        if (typeof(data111[i]) == 'string') {
            data111[i] = data111[i] + ' - done';
        }
    }
    console.log(data111);
    
    // Не трогаем
    return data111;

/* 
3) Разверните массив data наоборот при помощи цикла 
и запишите данные в массив result.
Должно получиться: [ 'Homework', 20, 'Shopping', 10, 5 ]
*/

    const data12 = [5, 10, 'Shopping', 20, 'Homework'];
    const result12 = [];

    // Пишем решение вот тут
    for (let i = 0; i < data12.length; i++) {
        result12[i] = data12[data12.length - 1 - i];
    }
    console.log(result12);
    // Не трогаем
    return result12;

// а если совместить две задачи вместе, получим

// первое решение
    const data123 = [5, 10, 'Shopping', 20, 'Homework'];
    const resULT123 = [];
    for (let i = 0; i < data123.length; i++) {
        if (typeof(data123[data123.length - 1 - i]) == 'number') {
            data123[data123.length - 1 - i] = data123[data123.length - 1 - i] * 2;
        }   
        if (typeof(data123[data123.length - 1 - i]) == 'string') {
            data123[data123.length - 1 - i] = data123[data123.length - 1 - i] + ' - done';
        }
        resULT123[i] = data123[data123.length - 1 - i];
    }
    console.log(resULT123);
    
// второе решение

    const dat = [5, 10, 'Shopping', 20, 'Homework'];
    const resul = [];
    for (let i = 0; i < dat.length; i++) {
        resul[i] = dat[dat.length - 1 - i];
        if (typeof(resul[i]) == 'number') {
            resul[i] = resul[i] * 2;
        }   
        if (typeof(resul[i]) == 'string') {
            resul[i] = resul[i] + ' - done';
        }
    }
    console.log(resul);

// задача **
// сделать елочку из звезд (астериск)

// При помощи циклов сделать треугольник с использованием астериска (*)
//      *
//     ***
//    *****
//   *******
//  *********
// ***********

const heightSpruce = 9;
let resultSpruce = '';

for (let i = 0; i < heightSpruce; i++) {
    for (let j = heightSpruce; j > (i + 1); j--) {
        resultSpruce += ' ';
    }
    for (let k = 0; k < (2 * i + 1); k++) {
        resultSpruce += '*';
    }
    resultSpruce += '\n';
}
console.log(resultSpruce);


const heightSpruce1 = 9;
let resultSpruce1 = '';

for (let i = 0; i < heightSpruce; i++) {
    resultSpruce1 += ' '.repeat(heightSpruce1 - i - 1) + '*'.repeat(2 * i + 1) + '\n';
}

console.log(resultSpruce1);

// -------------------- lesson 15 (23) -------------------- 

/*
file 'practice2.js'
*/


// -------------------- lesson 16 (24) -------------------- 
// функции, стрелочные функции
// Функции - наши действия в JS. Они используют различные типы данных, изменяют
// информацию так, как мы укажем. Также сокращает код как цикл

// Название функции должно быть глаголом с припиской того, над чем выполняется действие

function showFirstMessage() {
    console.log('hi');
}
showFirstMessage();

// Аргументы записываются в круглых скобках

function showFirstMessage(text, arg) {
    console.log(text);
}
showFirstMessage('hi');

// Если мы объявляем переменную внутри функции, снаружи функции она уже недоступна
// Такая переменная называется локальной, так как существует только внутри функции:

/* 
function showFirstMessage(text) {
    console.log(text);
    let numberic = 20;
}
showFirstMessage('hi');
console.log(numberic); -- numberic is nit defined
*/

// Однако можно использовать глобальную переменную внутри функции:

/* 
let numberic = 30;
function showFirstMessage(text) {
    console.log(text);
    numberic = 20; (можно дописать let, тогда обращение будет к глобальной и выведится 30)
}
showFirstMessage('hi');
console.log(numberic); -- numberic is nit defined
*/

// !!!!!!!!!!!!!!! Замыкание !!!!!!!!!!!!!!!

/*
let numberic = 30;
function showFirstMessage(text) {
    console.log(text);
    let numberic = 20; 
    console.log(numberic);
}
showFirstMessage('hi');
console.log(numberic);

-----> Выведется два числа. 20 и 30 <-----

let numberic = 30;
function showFirstMessage(text) {
    console.log(text);
    console.log(numberic);
}
showFirstMessage('hi');
console.log(numberic);

Что же происходит, когда программа выполняет функцию? Несколько шагов:

1) JavaScript создаёт новую область выполнения — локальную область выполнения.
2) Локальная область выполнения имеет свой набор переменных, 
которые будут локальными для этой области выполнения.
3) Новая область выполнения передаётся в стек выполнения. 
Думайте о стеке выполнения, как о механизме слежения за ходом исполнения программы.

-----> когда начнется выполнение строки console.log(numberic); внутри функции,
внутри функции не будет переменной numberic. В таком случае
функция будет искать переменную на 1 уровень выше (нашу глобальную, равную 30)
Если и на нем нет -- идет до самого высшего уровня, который ей доступен <-----

Глобальный код — обычное окружение, в котором ваш код выполняется изначально.
Код функции — всякий раз, когда поток выполнения попадает в тело функции.


Замыкание функций -- это сама функция вместе со всеми внешними переменными, которые ей доступны
*/

// return -- позволяет вернуть во "внешний мир" из функции:

function calc(a, b) {
    return(a + b);
    console.log(4, 3) // unreachable code -- мертвый код, который никогда не выполнится
    // Поэтому после return мы ничего не задаем
}
console.log(calc(4, 3));
console.log(calc(228, 337));
console.log(calc(25, 52));

function retURN() {
    let num = 50;
    return num;
}
const anotherNum = retURN();
console.log(anotherNum);


// Классификация функций

// 1) function declaration -- создается до начала выполнения скрипта, можно вызвать перед объявлением (схожесть с 'var')
// то, что было использовано выше

/* function example() {
 code
 } 
 
То есть можно спокойно сделать вот так (вывести значение функции до объявления функции)
Можно помещать все созданные функции вниз страницы, а сверху -- использовать их

console.log(calc(4, 3));
console.log(calc(228, 337));
console.log(calc(25, 52));

function calc(a, b) {
    return(a + b);
}

 
 */

// 2) function expression (функциональное выражение) -- создается только тогда, 
// когда доходит поток кода, можно вызвать ТОЛЬКО после объявления

/* let logger = function() {
 console.log('hello')
 }; 

 logger();

!!! ОБЯЗАТЕЛЬНО В КОНЦЕ ПОСТАВИТЬ ТОЧКУ С ЗАПЯТОЙ, В FUNCTION DECLARATION НЕ НУЖНО !!!
*/

// 3) Стрелочные функции () => -- не имеет своего контекста (this)

const calc = (a, b) => a + b; // упрощенный вариант

const calc = (a, b) => { return a + b }; // классический для многострочной структуры

// -------------------- lesson 17 (25) -------------------- 

// Аргументы функции

const usdRate = 28;
const eurRate = 32;

function convert(amount, rate) {
    console.log(rate * amount);
}
convert(500, usdRate);
convert(500, eurRate);

// -------------------- lesson 18 (26) --------------------
 
// важность return

// если полученное значение понадобится дальше -- требуется return

const usdCurrently = 28;
const eurCurrently = 32;
const discount = 0.9;

function convert(amount, currently) {
    return currently * amount;
}

function promotion(result) {
    console.log(result * discount)
}

convert(500, usdCurrently);
convert(500, eurCurrently);
promotion(convert(500, usdCurrently)); // функция внутри функции может быть не практично
// тогда:
const resss = convert(500, usdCurrently);
promotion(resss);


// после return может быть возвращено любое значение -- число, объект, массив, другая функция
// в основе приема компонента высшего порядка лежит то, что функция возвращает другую функцию
// example: return function() {}

// прекращение работы функции 

function text() {
    for (let i = 0; i < 5; i++) {
        console.log(i);
        if (i === 3) {return}
    }
    console.log('done');
}

test();

// что же будет возвращать function? undefined
// любая функция что-то возвращает, если ничего не задано -- undefined. проверим это:

function doNothing() {};
console.log(doNothing() === undefined);

// вывод 'true', нет фактически заданного return -- вывод undefined

// почему в консоли в браузере при выполнении когда мы когда-нибудь можем увидеть undefined?
// откроем консоль, напишем 'console.log('10');
// выведется 10 и ниже undefined.
// console.log -- функция, console -- Объект, .log -- метод (функция записанная внутри объекта)
// так будет вести себя любая функция, не содержащая return {smth}

// после return не ставьте перенос строки!
// JS автоматически подставит ; после return, следовательно все что ниже - unreachable (недостижимо)

// Итог: если функция должна вернуть какой-то результат для дальнейшей работы - пригодится return
// Также всегда можно досрочно закончить функцию, используя return


// ------------------------------ Homework #6 (после урока 26) ------------------------------

/*
1) Создайте функцию, которая будет на вход принимать 1 аргумент с именем человека и возвращать строку.

Пример: вызов функции sayHello('Антон') возвращает строку "Привет, Антон!". В решении вызывать функцию не 
нужно, программа сделает это за вас.

P.S. возвращать - это использовать ключевое слово return.
P.S.S. Это классическая функция-модификатор, которых мы дальше по курсу будем создавать еще много в разных видах.
*/

// Решение

function sayHello(name) {
    return `Привет, ${name}!`;
}
sayHello('Artem');
console.log(sayHello('Artem'));

/*
2) Создайте функцию, которая принимает в себя 1 аргумент в виде целого числа и возвращает массив из трех чисел: 
одно на 1 меньше, сам аргумент, и число на 1 больше.

Пример: вызов функции returnNeighboringNumbers(5) возвращает массив в виде [4, 5, 6].
*/

// Решение
function returnNeighboringNumbers(massive) {
    return[massive - 1, massive, massive + 1]
}

console.log(returnNeighboringNumbers(-100));

/* 3) Создайте функцию, которая будет принимать в себя 2 аргумента, оба числа. Первое число - это база, 
второе число - это сколько раз нужно будет повторить это число в прогрессии. (Смотри пример ниже). 
Функция должна возвращать строку (или число в особых случаях, о которых ниже), где эти числа идут по 
порядку, разделенные тремя дефисами "---". После последнего числа их не должно быть.

Если второй аргумент не является числом, равен или меньше нуля - то возвращать просто первый аргумент. 
(Проверяем через оператор typeof)

Примеры:

Вызов функции getMathResult(5, 3) даст ответ 5---10---15

Вызов функции getMathResult(3, 10) даст ответ 3---6---9---12---15---18---21---24---27---30

Вызов функции getMathResult(10, 5) даст ответ 10---20---30---40---50

Вызов функции getMathResult(10, '5') даст ответ 10

Вызов функции getMathResult(10, 0) даст ответ 10

Вызов функции getMathResult(20, -5) даст ответ 20

Эта задача уже ближе к реальности, когда вам нужно учитывать и тип данных у аргументов, 
проверять их и продумывать логику работы внутри. Обратите внимание на прогрессию, 
она рассчитывается по простой формуле умножения. Если первый аргумент 5, а второй 3, 
то число повторяется 3 раза, каждый раз увеличиваясь на само себя. 
Это базовая математика, которая и нужна для работы в 95% случае на фронтенде.
*/

function getMathResult(num, times) {
    if (times <= 0 || typeof(times) !== 'number') {
        return num;
    } 
    let stringer = '';
    for (let i = 1; i <= times; i++) {
        if (i === times) {
            stringer += `${num * i}`;
        } else {
            stringer += `${num * i}---`;
        }
    }
    return(stringer);
}    
console.log(getMathResult(10, 5));



// -------------------- lesson 19 (27) --------------------
 
// Методы и свойства у строк и чисел
// Методы -- вспомогательные функции, свойства -- вспомогательные значения

const str = 'test';
console.log(str.length); // свойство -- Количество символов в строке, 

const arr = [1, 2, 3, 4, 5, 10]; 
console.log(arr.length); // свойство кол-во элементов внутри массива
// Свойство не вызывается, пишется через точку
// Методы, которые будут вспомогательными функциями уже вызываются при помощи ()

// все методы и свойства можно найти на MDN -- тип данных string, слева функции и свойства
// или браузером -- console.dir(Number);

// Можно указать конкретный элемент в строке:
console.log(str[2]); // вывод 's' -- 3 символ по порядку
// При попытке заменить символ в строке -- ничего не выйдет
console.log(str[2] = 'd'); // вывод 'd'
console.log(str); // вывод 'test'
// Напрямую нельзя изменить строку (отрезать часть строки, заменить символ). Для этого есть методы

// Метод изменения регистра
console.log(str.toUpperCase()); // вывод 'TEST', так как содержит новое значение
// Напрямую не изменяет начальную строку
console.log(str.toLowerCase());
console.log(str); // вывод 'test'

// Метод, который позволяет найти кусок строки и указать, с какой позиции он начинается (поиск подстроки)

const fruit = 'Some fru fruit'
console.log(fruit.indexOf('fruit'));
// Значение '-1' дает понять, что такой строки не было найдено
// Если строка неизменяема, как мы сможем ее изменить?

// 3 метода взаимодействия со строками

const logg = 'Hello world';
console.log(logg.slice(6, 11)); // Второй аргумент не включительно
console.log(logg.slice(6)); // с 6 символа до конца
console.log(logg.slice(-5, -1)); // Отсчет справа

// метод substring -- похож на предыдущий, разница в том, что 1 аргумент можно задать больше чем 2
// substring не поддерживает отрицательные значения

// метод substr -- вместо 2 аргумента конца мы указываем длину, которую хотим вырезать из строки

// методы для чисел -- для работы с числами есть отдельная библиотека Math

const numBERRR = 12.2;
console.log(Math.round(numBERRR));


const test = '12.2px';
console.log(parseInt(test)); // Перевод числа в другую СС, получим 12 -- числовой тип данных
// применение метода не по назначению, но почему бы и нет
console.log(parseFloat(test)); // Возврат числа с плавающей точкой


// -------------------- lesson 20 --------------------
 
// -------------------- lesson 21 --------------------
 
// -------------------- lesson 22 --------------------
 
// -------------------- lesson 23 --------------------
 
// -------------------- lesson 24 --------------------
 
// -------------------- lesson 25 --------------------
 
// -------------------- lesson 26 --------------------
 
// -------------------- lesson 27 --------------------
 
// -------------------- lesson 28 --------------------
 
// -------------------- lesson 29 --------------------
 
// -------------------- lesson 30 --------------------
 
// -------------------- lesson 31 --------------------
 
// -------------------- lesson 32 --------------------
 
// -------------------- lesson 33 --------------------
 
// -------------------- lesson 34 --------------------
 
// -------------------- lesson 35 --------------------
 
// -------------------- lesson 36 --------------------
 
// -------------------- lesson 37 --------------------
 
// -------------------- lesson 38 --------------------
 
// -------------------- lesson 39 --------------------
 
// -------------------- lesson 40 --------------------
 
// -------------------- lesson 41 --------------------
 
// -------------------- lesson 42 --------------------
 
// -------------------- lesson 43 --------------------
 
// -------------------- lesson 44 --------------------
 
// -------------------- lesson 45 --------------------
 
// -------------------- lesson 46 --------------------
 
// -------------------- lesson 47 --------------------
 
// -------------------- lesson 48 --------------------
 
// -------------------- lesson 49 --------------------
 
// -------------------- lesson 50 --------------------
 
// -------------------- lesson 51 --------------------
 
